{
    "openapi": "3.0.1",
    "info": {
    "title": "Dynatrace Cluster API",
    "description": "Dynatrace Managed exposes cluster-wide functionality via REST endpoints. This interactive documentation also acts as a REST client you can use to interact with Dynatrace Managed clusters. \n\nTo authorize, use the API Token generated in [Settings - API Tokens page](/cmc#cm/apiToken). The HTTP status code of the response shows the result of your request. The expected response code for a successful request is documented individually per REST endpoint. Additionally the following error response codes can occur in our REST interface:\n\n* 400 - Bad Request: Some request parameters are not correct. See response body for details.\n* 401 - Unauthorized: A valid authorization header is required but is missing.\n* 403 - Forbidden: Execution of request is not allowed, e.g. api-token is invalid.\n* 404 - Not Found: Endpoint does not exist or some entities could not be found.\n* 500 - Internal Server Error: See response body for details.\n* 556 - Upgrade in progress: Operation couldn't be performed during the upgrade.\n\nNotes about compatibility:\n* Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this.\n* We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.",
    "version": "2.0"
    },
    "servers": [
    {
    "variables": {}
    }
    ],
    "security": [
    {
    "Api-Token": []
    }
    ],
    "tags": [
    {
    "name": "Environments",
    "description": "Manage environments"
    },
    {
    "name": "User management",
    "description": "Manage user sessions"
    },
    {
    "name": "Remote access",
    "description": "Manage remote access requests"
    },
    {
    "name": "License",
    "description": "View license information"
    },
    {
    "name": "Tokens",
    "description": "Manage Dynatrace API authentication tokens"
    },
    {
    "name": "Network zones",
    "description": "Manage network zones"
    },
    {
    "name": "ActiveGates",
    "description": "View information about your ActiveGates"
    },
    {
    "name": "ActiveGates - Auto-update configuration",
    "description": "Manage ActiveGate auto-update settings."
    },
    {
    "name": "ActiveGates - Auto-update jobs",
    "description": "Manage ActiveGate auto-update jobs."
    },
    {
    "name": "Deployment",
    "description": "View available ActiveGate versions"
    },
    {
    "name": "IAM - policies management",
    "description": "Create, update, delete and read IAM policies"
    },
    {
    "name": "IAM - policies bindings",
    "description": "Bind policies in the context of organizational structure"
    },
    {
    "name": "IAM - organizational levels",
    "description": "Organizational levels available for policies repository and bindings"
    },
    {
    "name": "IAM - configuration resource",
    "description": "Configuration available for validation"
    },
    {
    "name": "Settings - Objects",
    "description": "Manage settings objects"
    },
    {
    "name": "Settings - Schemas",
    "description": "View settings schemas"
    }
    ],
    "paths": {
    "/license/consumption/hour": {
    "get": {
    "tags": [
    "License"
    ],
    "summary": "Retrieve license consumption",
    "operationId": "getBillingHour",
    "parameters": [
    {
    "name": "startTs",
    "in": "query",
    "description": "Begin timestamp",
    "schema": {
    "type": "integer",
    "format": "int64"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/BillingRequestDto"
    }
    }
    }
    },
    "400": {
    "description": "Bad request. Provided timestamp is incorrect."
    },
    "500": {
    "description": "Operation failed"
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/license/consumption": {
    "get": {
    "tags": [
    "License"
    ],
    "summary": "Export license consumption data",
    "description": "Export license consumption data as a ZIP archive.",
    "operationId": "getBillingArchive",
    "parameters": [
    {
    "name": "startTs",
    "in": "query",
    "description": "Start timestamp (30 days ago by default)",
    "schema": {
    "type": "integer",
    "format": "int64"
    }
    },
    {
    "name": "endTs",
    "in": "query",
    "description": "End timestamp (2 hours ago by default, values from the last 2 hours are not allowed)",
    "schema": {
    "type": "integer",
    "format": "int64"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "OK - license consumption data export will start",
    "content": {
    "application/octet-stream": {}
    }
    },
    "400": {
    "description": "Bad request. Provided time range is incorrect."
    },
    "429": {
    "description": "License consumption data is already being exported. Please wait for the first request to finish before requesting another export."
    },
    "500": {
    "description": "Operation failed"
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/environments/{id}": {
    "get": {
    "tags": [
    "Environments"
    ],
    "summary": "Gets the properties of the specified environment.",
    "operationId": "getSingleEnvironment",
    "parameters": [
    {
    "name": "id",
    "in": "path",
    "description": "The ID of the environment.",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "includeConsumptionInfo",
    "in": "query",
    "description": "If true, consumption information (limits, usage) is returned for this environment.\n\nReturned usage is typically up to 1 hour old. To obtain fresher data, you can use **includeUncachedConsumptionInfo** parameter instead.",
    "schema": {
    "type": "boolean"
    }
    },
    {
    "name": "includeStorageInfo",
    "in": "query",
    "description": "If true, storage information (limits, usage) is returned for this environment.",
    "schema": {
    "type": "boolean"
    }
    },
    {
    "name": "includeUncachedConsumptionInfo",
    "in": "query",
    "description": "If true, uncached consumption information (limits, usage) is returned for this environment.\n\nUp to date consumption will be calculated. If both this parameter and **includeConsumptionInfo** are set, **includeUncachedConsumptionInfo** will take priority.",
    "schema": {
    "type": "boolean"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Successful operation.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/Environment"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "put": {
    "tags": [
    "Environments"
    ],
    "summary": "Updates an existing environment or creates a new one.",
    "description": "If the environment with the specified ID does not exist, a new environment will be created.",
    "operationId": "createOrUpdateEnvironment",
    "parameters": [
    {
    "name": "id",
    "in": "path",
    "description": "The ID of the environment to update.\n\n If you set the ID in the body as well, it must match this ID.",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "createToken",
    "in": "query",
    "description": "If true, a token management token with the scopes 'apiTokens.read' and 'apiTokens.write' (for usage with token API v2) and 'TenantTokenManagement' (for usage with token API v1) is created when creating a new environment. This token is then returned in the response body. It can be used within the newly created environment to create other tokens for configuring this environment.",
    "schema": {
    "type": "boolean",
    "default": false
    }
    }
    ],
    "requestBody": {
    "description": "JSON body of the request, containing updated parameters of the environment.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/Environment"
    }
    }
    }
    },
    "responses": {
    "201": {
    "description": "Success. The new environment has been created. The response body contains the ID, the name and also a token management token if 'createToken' is 'true'.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/EnvironmentShortRepresentation"
    }
    }
    }
    },
    "204": {
    "description": "Success. The environment has been updated. Response doesn't have a body."
    },
    "400": {
    "description": "Failed. The input is invalid."
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "delete": {
    "tags": [
    "Environments"
    ],
    "summary": "Deletes the specified environment. An environment must be disabled before it can be deleted.",
    "operationId": "deleteEnvironment",
    "parameters": [
    {
    "name": "id",
    "in": "path",
    "description": "The ID of the environment to be deleted.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "204": {
    "description": "Deleted. Response does not have a body."
    },
    "400": {
    "description": "Failed. For example, if an environment is not disabled."
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/environments/{id}/tokenManagementToken": {
    "post": {
    "tags": [
    "Environments"
    ],
    "summary": "Creates a new tenant management token for an environment.",
    "description": "The newly created token is owned by the same user who owns the token used for authentication of creation call. \nIt has the scopes 'apiTokens.read' and 'apiTokens.write' (for usage with token API v2) and 'TenantTokenManagement' (for usage with token API v1).",
    "operationId": "createTokenManagementToken",
    "parameters": [
    {
    "name": "id",
    "in": "path",
    "description": "The ID of the environment where the token is valid.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "description": "The JSON body of the request. Contains parameters of the token.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/CreateEnvironmentTokenManagementToken"
    }
    }
    }
    },
    "responses": {
    "201": {
    "description": "Success. The token has been created. The response body contains the token itself",
    "headers": {
    "Location": {
    "description": "Token Id",
    "style": "simple",
    "schema": {
    "type": "string"
    }
    }
    },
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/Token"
    }
    }
    }
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`EnvironmentTokenManagement` (\"Token Management\" Token creation for existing environments)"
    ]
    }
    },
    "/environments": {
    "get": {
    "tags": [
    "Environments"
    ],
    "summary": "Lists all existing environments.",
    "operationId": "getAllEnvironments",
    "parameters": [
    {
    "name": "nextPageKey",
    "in": "query",
    "description": "The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response. \n\nThe first page is always returned if you don't specify the **nextPageKey** query parameter. \n\nWhen the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters. ",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "pageSize",
    "in": "query",
    "description": "The amount of environments in a single response payload. \n\nThe maximal allowed page size is 1000. \n\nIf not set, 100 is used.",
    "schema": {
    "type": "integer",
    "format": "int64"
    }
    },
    {
    "name": "sort",
    "in": "query",
    "description": "The sort order. Possible sorts orders are:\n * 'name' (without quotes): Sort by name ascending.\n * '-name' (without quotes): Sort by name descending.\n * 'creationDate' (without quotes): Sort by creation date ascending.\n * '-creationDate' (without quotes): Sort by name descending.\n",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "filter",
    "in": "query",
    "description": "Specifies the filter of the query. \n\nYou can set one or several of the following criteria:\n* Name: `name(string)`. The name can be either a substring or the full name of an environment. Case-insensitive.\n* Trial: `trial(true)` or `trial(false)`. Only includes trial environments if true is specified or only non-trial environments if false is specified.\n* State: `state(ENABLED)` or `state(DISABLED)`.\n* Tag: `tag(string)`. To filter by multiple tags by applying OR logic use `tag(string1,string2)`. To filter by multiple tags by applying AND logic use `tag(string1),tag(string2)`.\nTo set several criteria, separate them with a comma (`,`). Only results, matching **all** criteria, are included into response.\n",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "includeConsumptionInfo",
    "in": "query",
    "description": "If true, consumption information (limits, usage) is returned for each environment.\n\nReturned usage is typically up to 1 hour old. To obtain fresher data, you can use **includeUncachedConsumptionInfo** parameter instead.",
    "schema": {
    "type": "boolean"
    }
    },
    {
    "name": "includeStorageInfo",
    "in": "query",
    "description": "If true, storage information (limits, usage) is returned for each environment.",
    "schema": {
    "type": "boolean"
    }
    },
    {
    "name": "includeUncachedConsumptionInfo",
    "in": "query",
    "description": "If true, uncached consumption information (limits, usage) is returned for each environment.\n\nUp to date consumption will be calculated. Calculation may be time consuming, so it's recommended to use **includeConsumptionInfo** parameter instead.\n\nIf both this parameter and **includeConsumptionInfo** are set, **includeUncachedConsumptionInfo** will take priority.",
    "schema": {
    "type": "boolean"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Successful operation.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/EnvironmentList"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "post": {
    "tags": [
    "Environments"
    ],
    "summary": "Creates a new environment.",
    "operationId": "createEnvironment",
    "parameters": [
    {
    "name": "createToken",
    "in": "query",
    "description": "If true, a token management token with the scopes 'apiTokens.read' and 'apiTokens.write' (for usage with token API v2) and 'TenantTokenManagement' (for usage with token API v1) is created when creating a new environment. This token is then returned in the response body. It can be used within the newly created environment to create other tokens for configuring this environment.",
    "schema": {
    "type": "boolean",
    "default": false
    }
    }
    ],
    "requestBody": {
    "description": "The JSON body of the request. The body must not provide an ID as it will be automatically assigned by the Dynatrace server.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/Environment"
    }
    }
    },
    "required": true
    },
    "responses": {
    "201": {
    "description": "Success. The environment has been created and started. The response body contains the generated ID of the environment and a token with the scopes 'apiTokens.read' and 'apiTokens.write' (for usage with token API v2) and 'TenantTokenManagement'. The location header contains the generated ID as well.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/EnvironmentShortRepresentation"
    }
    }
    }
    },
    "400": {
    "description": "Failed. The input is invalid."
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/remoteaccess/requests/{requestId}/state": {
    "put": {
    "tags": [
    "Remote access"
    ],
    "summary": "Change state of access request",
    "operationId": "accessRequestChangeState",
    "parameters": [
    {
    "name": "requestId",
    "in": "path",
    "description": "Request id param",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "description": "The JSON body of the request, containing new state of access request.",
    "content": {
    "*/*": {
    "schema": {
    "$ref": "#/components/schemas/AccessRequestStateData"
    }
    }
    }
    },
    "responses": {
    "200": {
    "description": "Success"
    },
    "400": {
    "description": "Bad request"
    },
    "403": {
    "description": "Approving remote access request is disabled"
    },
    "404": {
    "description": "Access request not found"
    },
    "409": {
    "description": "Access request was found, but it's already expired"
    },
    "500": {
    "description": "Operation failed"
    }
    },
    "x-token-scopes": [
    "`ControlManagement` (ControlManagement)",
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/remoteaccess/requests": {
    "get": {
    "tags": [
    "Remote access"
    ],
    "summary": "Get all access requests",
    "operationId": "getAllAccessRequests",
    "parameters": [],
    "responses": {
    "200": {
    "description": "Successful",
    "content": {
    "application/json": {
    "schema": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/AccessRequestData"
    }
    }
    }
    }
    },
    "403": {
    "description": "Approving remote access request is disabled"
    }
    },
    "x-token-scopes": [
    "`ControlManagement` (ControlManagement)",
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "post": {
    "tags": [
    "Remote access"
    ],
    "summary": "Grant remote access permission",
    "operationId": "addAccessRequest",
    "parameters": [],
    "requestBody": {
    "description": "The JSON body of the request, containing parameters of access request.",
    "content": {
    "*/*": {
    "schema": {
    "$ref": "#/components/schemas/CreateAccessRequestDto"
    }
    }
    }
    },
    "responses": {
    "201": {
    "description": "Successfully created",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/AccessRequestData"
    }
    }
    }
    },
    "400": {
    "description": "Invalid parameters"
    },
    "403": {
    "description": "Approving remote access request is disabled"
    },
    "500": {
    "description": "Operation failed"
    },
    "513": {
    "description": "Mission Control is unavailable"
    }
    },
    "x-token-scopes": [
    "`ControlManagement` (ControlManagement)",
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/remoteaccess/requests/{requestId}": {
    "get": {
    "tags": [
    "Remote access"
    ],
    "summary": "Get access request",
    "operationId": "getAccessRequest",
    "parameters": [
    {
    "name": "requestId",
    "in": "path",
    "description": "Request id param",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Successful",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/AccessRequestData"
    }
    }
    }
    },
    "400": {
    "description": "Bad request"
    },
    "403": {
    "description": "Approving remote access request is disabled"
    },
    "404": {
    "description": "Not found"
    }
    },
    "x-token-scopes": [
    "`ControlManagement` (ControlManagement)",
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/clusterConfig/userSessions": {
    "get": {
    "tags": [
    "User management"
    ],
    "summary": "Get user sessions configuration",
    "operationId": "getConcurrentSessionPolicyConfig",
    "parameters": [],
    "responses": {
    "200": {
    "description": "Successful",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/UserSessionsConfig"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "put": {
    "tags": [
    "User management"
    ],
    "summary": "Update user sessions configuration",
    "operationId": "updateConcurrentSessionPolicyConfig",
    "parameters": [],
    "requestBody": {
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/UserSessionsConfig"
    }
    }
    }
    },
    "responses": {
    "200": {
    "description": "Successful"
    },
    "400": {
    "description": "Wrong parameters"
    },
    "510": {
    "description": "Configuration update failed"
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/userSessions": {
    "get": {
    "tags": [
    "User management"
    ],
    "summary": "Get user sessions",
    "operationId": "getUserSessions",
    "parameters": [
    {
    "name": "userId",
    "in": "query",
    "description": "User ID (optional)",
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json": {
    "schema": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/UserSession"
    }
    }
    }
    }
    },
    "500": {
    "description": "Operation failed"
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "delete": {
    "tags": [
    "User management"
    ],
    "summary": "Remove user sessions for a given user",
    "operationId": "removeUserSession",
    "parameters": [
    {
    "name": "userId",
    "in": "query",
    "description": "User ID (mandatory)",
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success"
    },
    "400": {
    "description": "Bad request. User id must be filled in."
    },
    "404": {
    "description": "User sessions not found"
    },
    "500": {
    "description": "Operation failed"
    },
    "510": {
    "description": "Failed to invalidate sessions"
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/activeGates/{agId}/autoUpdate": {
    "get": {
    "tags": [
    "ActiveGates - Auto-update configuration"
    ],
    "summary": "Gets the configuration of auto-update for the specified ActiveGate",
    "operationId": "getAutoUpdateConfigById",
    "parameters": [
    {
    "name": "agId",
    "in": "path",
    "description": "The ID of the required ActiveGate.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ActiveGateAutoUpdateConfig"
    }
    }
    }
    },
    "404": {
    "description": "Not found. See response body for details.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "put": {
    "tags": [
    "ActiveGates - Auto-update configuration"
    ],
    "summary": "Updates the configuration of auto-update for the specified ActiveGate",
    "operationId": "putAutoUpdateConfigById",
    "parameters": [
    {
    "name": "agId",
    "in": "path",
    "description": "The ID of the required ActiveGate.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "description": "JSON body of the request, containing auto update parameters.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ActiveGateAutoUpdateConfig"
    }
    }
    },
    "required": true
    },
    "responses": {
    "204": {
    "description": "Success. The auto-update configuration have been updated. Response doesn't have a body."
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/activeGates/{agId}/autoUpdate/validator": {
    "post": {
    "tags": [
    "ActiveGates - Auto-update configuration"
    ],
    "summary": "Validates the payload for the `POST /activeGates/{agId}/autoUpdate` request.",
    "operationId": "validateAutoUpdateConfigById",
    "parameters": [
    {
    "name": "agId",
    "in": "path",
    "description": "The ID of the required ActiveGate.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "description": "JSON body of the request, containing auto update parameters.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ActiveGateAutoUpdateConfig"
    }
    }
    },
    "required": true
    },
    "responses": {
    "204": {
    "description": "Validated. The submitted auto-update configuration is valid. Response doesn't have a body."
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/activeGates/autoUpdate": {
    "get": {
    "tags": [
    "ActiveGates - Auto-update configuration"
    ],
    "summary": "Gets the global auto-update configuration of cluster ActiveGates.",
    "operationId": "getClusterGlobalAutoUpdateConfig",
    "parameters": [],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ActiveGateGlobalAutoUpdateConfig"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "put": {
    "tags": [
    "ActiveGates - Auto-update configuration"
    ],
    "summary": "Puts the global auto-update configuration of cluster ActiveGates.",
    "operationId": "putClusterGlobalAutoUpdateConfig",
    "parameters": [],
    "requestBody": {
    "description": "JSON body of the request, containing global auto update parameters.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ActiveGateGlobalAutoUpdateConfig"
    }
    }
    },
    "required": true
    },
    "responses": {
    "204": {
    "description": "Success. The global auto-update configuration have been updated. Response doesn't have a body."
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/activeGates/autoUpdate/validator": {
    "post": {
    "tags": [
    "ActiveGates - Auto-update configuration"
    ],
    "summary": "Validates the payload for the `POST /activeGates/autoUpdate` request.",
    "operationId": "validateClusterGlobalAutoUpdateConfig",
    "parameters": [],
    "requestBody": {
    "description": "JSON body of the request, containing global auto update parameters.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ActiveGateGlobalAutoUpdateConfig"
    }
    }
    },
    "required": true
    },
    "responses": {
    "204": {
    "description": "Validated. The submitted configuration is valid. Response doesn't have a body."
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/activeGates/autoUpdate/{envId}": {
    "get": {
    "tags": [
    "ActiveGates - Auto-update configuration"
    ],
    "summary": "Gets the global auto-update configuration of environment ActiveGates.",
    "operationId": "getGlobalAutoUpdateConfigForTenant",
    "parameters": [
    {
    "name": "envId",
    "in": "path",
    "description": "The ID of the environment.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ActiveGateGlobalAutoUpdateConfig"
    }
    }
    }
    },
    "404": {
    "description": "Not found. See response body for details.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "put": {
    "tags": [
    "ActiveGates - Auto-update configuration"
    ],
    "summary": "Puts the global auto-update configuration of environment ActiveGates.",
    "operationId": "putGlobalAutoUpdateConfigForTenant",
    "parameters": [
    {
    "name": "envId",
    "in": "path",
    "description": "The ID of the environment.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "description": "JSON body of the request, containing global auto update parameters.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ActiveGateGlobalAutoUpdateConfig"
    }
    }
    },
    "required": true
    },
    "responses": {
    "204": {
    "description": "Success. The global auto-update configuration have been updated. Response doesn't have a body."
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/activeGates/autoUpdate/{envId}/validator": {
    "post": {
    "tags": [
    "ActiveGates - Auto-update configuration"
    ],
    "summary": "Validates the payload for the `POST /activeGates/autoUpdate/{envId}` request.",
    "operationId": "validateGlobalAutoUpdateConfigForTenant",
    "parameters": [
    {
    "name": "envId",
    "in": "path",
    "description": "The ID of the environment.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "description": "JSON body of the request, containing global auto update parameters.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ActiveGateGlobalAutoUpdateConfig"
    }
    }
    },
    "required": true
    },
    "responses": {
    "204": {
    "description": "Validated. The submitted configuration is valid. Response doesn't have a body."
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/activeGates/updateJobs": {
    "get": {
    "tags": [
    "ActiveGates - Auto-update jobs"
    ],
    "summary": "List ActiveGates with update jobs",
    "description": "The response includes ActiveGates that have both completed (successful and failed) jobs and jobs in progress.",
    "operationId": "getAllUpdateJobList",
    "parameters": [
    {
    "name": "from",
    "in": "query",
    "description": "The start of the requested timeframe for update jobs. \n\nYou can use one of the following formats: \n* Timestamp in UTC milliseconds. \n* Human-readable format of `2021-01-25T05:57:01.123+01:00`. If no time zone is specified, UTC is used. You can use a space character instead of the `T`. Seconds and fractions of a second are optional. \n* Relative timeframe, back from now. The format is `now-NU/A`, where `N` is the amount of time, `U` is the unit of time, and `A` is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, `now-1y/w` is one year back, aligned by a week. \nYou can also specify relative timeframe without an alignment: `now-NU`. \nSupported time units for the relative timeframe are: \n   * `m`: minutes \n   * `h`: hours \n   * `d`: days \n   * `w`: weeks \n   * `M`: months \n   * `y`: years \n\nIf not set, the relative timeframe of one day is used (`now-1d`). \n\nMaximum timeframe is 31 days.",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "to",
    "in": "query",
    "description": "The end of the requested timeframe for update jobs. \n\nYou can use one of the following formats: \n* Timestamp in UTC milliseconds. \n* Human-readable format of `2021-01-25T05:57:01.123+01:00`. If no time zone is specified, UTC is used. You can use a space character instead of the `T`. Seconds and fractions of a second are optional. \n* Relative timeframe, back from now. The format is `now-NU/A`, where `N` is the amount of time, `U` is the unit of time, and `A` is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, `now-1y/w` is one year back, aligned by a week. \nYou can also specify relative timeframe without an alignment: `now-NU`. \nSupported time units for the relative timeframe are: \n   * `m`: minutes \n   * `h`: hours \n   * `d`: days \n   * `w`: weeks \n   * `M`: months \n   * `y`: years \n\nIf not set, the current timestamp is used.",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "startVersionCompareType",
    "in": "query",
    "description": "Filters the resulting set of update jobs by the specified initial version. \n\n Specify the comparison operator here.",
    "schema": {
    "type": "string",
    "enum": [
    "EQUAL",
    "GREATER",
    "GREATER_EQUAL",
    "LOWER",
    "LOWER_EQUAL"
    ],
    "default": "EQUAL"
    }
    },
    {
    "name": "startVersion",
    "in": "query",
    "description": "Filters the resulting set of update-jobs by the initial version (required format `<major>.<minor>.<revision>`).",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "updateType",
    "in": "query",
    "description": "Filters the resulting set of update-jobs by the update type.",
    "schema": {
    "type": "string",
    "enum": [
    "ACTIVE_GATE",
    "REMOTE_PLUGIN_AGENT",
    "SYNTHETIC",
    "Z_REMOTE"
    ]
    },
    "example": "ACTIVE_GATE"
    },
    {
    "name": "targetVersionCompareType",
    "in": "query",
    "description": "Filters the resulting set of update jobs by the specified target version. \n\n Specify the comparison operator here.",
    "schema": {
    "type": "string",
    "enum": [
    "EQUAL",
    "GREATER",
    "GREATER_EQUAL",
    "LOWER",
    "LOWER_EQUAL"
    ],
    "default": "EQUAL"
    }
    },
    {
    "name": "targetVersion",
    "in": "query",
    "description": "Filters the resulting set of update-jobs by the target version (required format `<major>.<minor>.<revision>`).",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "lastUpdates",
    "in": "query",
    "description": "If `true`, filters the resulting set of update jobs to the most recent update of each type.",
    "schema": {
    "type": "boolean",
    "default": false
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/UpdateJobsAll"
    }
    }
    }
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/activeGates/{agId}/updateJobs": {
    "get": {
    "tags": [
    "ActiveGates - Auto-update jobs"
    ],
    "summary": "Lists update jobs for the specified ActiveGate",
    "description": "The job can update the ActiveGate to the specified version or the latest available one.",
    "operationId": "getUpdateJobListByAgId",
    "parameters": [
    {
    "name": "agId",
    "in": "path",
    "description": "The ID of the required ActiveGate.",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "from",
    "in": "query",
    "description": "The start of the requested timeframe for update jobs. \n\nYou can use one of the following formats: \n* Timestamp in UTC milliseconds. \n* Human-readable format of `2021-01-25T05:57:01.123+01:00`. If no time zone is specified, UTC is used. You can use a space character instead of the `T`. Seconds and fractions of a second are optional. \n* Relative timeframe, back from now. The format is `now-NU/A`, where `N` is the amount of time, `U` is the unit of time, and `A` is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, `now-1y/w` is one year back, aligned by a week. \nYou can also specify relative timeframe without an alignment: `now-NU`. \nSupported time units for the relative timeframe are: \n   * `m`: minutes \n   * `h`: hours \n   * `d`: days \n   * `w`: weeks \n   * `M`: months \n   * `y`: years \n\nIf not set, the relative timeframe of one week is used (`now-1w`). \n\nMaximum timeframe is 31 days.",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "to",
    "in": "query",
    "description": "The end of the requested timeframe for update jobs. \n\nYou can use one of the following formats: \n* Timestamp in UTC milliseconds. \n* Human-readable format of `2021-01-25T05:57:01.123+01:00`. If no time zone is specified, UTC is used. You can use a space character instead of the `T`. Seconds and fractions of a second are optional. \n* Relative timeframe, back from now. The format is `now-NU/A`, where `N` is the amount of time, `U` is the unit of time, and `A` is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, `now-1y/w` is one year back, aligned by a week. \nYou can also specify relative timeframe without an alignment: `now-NU`. \nSupported time units for the relative timeframe are: \n   * `m`: minutes \n   * `h`: hours \n   * `d`: days \n   * `w`: weeks \n   * `M`: months \n   * `y`: years \n\nIf not set, the current timestamp is used.",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "startVersionCompareType",
    "in": "query",
    "description": "Filters the resulting set of update jobs by the specified initial version. \n\n Specify the comparison operator here.",
    "schema": {
    "type": "string",
    "enum": [
    "EQUAL",
    "GREATER",
    "GREATER_EQUAL",
    "LOWER",
    "LOWER_EQUAL"
    ],
    "default": "EQUAL"
    }
    },
    {
    "name": "startVersion",
    "in": "query",
    "description": "Filters the resulting set of update-jobs by the initial version (required format `<major>.<minor>.<revision>`).",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "updateType",
    "in": "query",
    "description": "Filters the resulting set of update-jobs by the update type.",
    "schema": {
    "type": "string",
    "enum": [
    "ACTIVE_GATE",
    "REMOTE_PLUGIN_AGENT",
    "SYNTHETIC",
    "Z_REMOTE"
    ]
    },
    "example": "ACTIVE_GATE"
    },
    {
    "name": "targetVersionCompareType",
    "in": "query",
    "description": "Filters the resulting set of update jobs by the specified target version. \n\n Specify the comparison operator here.",
    "schema": {
    "type": "string",
    "enum": [
    "EQUAL",
    "GREATER",
    "GREATER_EQUAL",
    "LOWER",
    "LOWER_EQUAL"
    ],
    "default": "EQUAL"
    }
    },
    {
    "name": "targetVersion",
    "in": "query",
    "description": "Filters the resulting set of update-jobs by the target version (required format `<major>.<minor>.<revision>`).",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "lastUpdates",
    "in": "query",
    "description": "If `true`, filters the resulting set of update jobs to the most recent update of each type.",
    "schema": {
    "type": "boolean",
    "default": false
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/UpdateJobList"
    }
    }
    }
    },
    "404": {
    "description": "Not found. See response body for details.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "post": {
    "tags": [
    "ActiveGates - Auto-update jobs"
    ],
    "summary": "Creates a new update job for the specified ActiveGate",
    "operationId": "createUpdateJobForAg",
    "parameters": [
    {
    "name": "agId",
    "in": "path",
    "description": "The ID of the required ActiveGate.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "description": "JSON body of the request, containing update-job parameters.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/UpdateJob"
    }
    }
    },
    "required": true
    },
    "responses": {
    "201": {
    "description": "Success. The update-job have been created.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/UpdateJob"
    }
    }
    }
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/activeGates/{agId}/updateJobs/{jobId}": {
    "get": {
    "tags": [
    "ActiveGates - Auto-update jobs"
    ],
    "summary": "Gets the parameters of the specified update job",
    "operationId": "getUpdateJobByJobIdForAg",
    "parameters": [
    {
    "name": "agId",
    "in": "path",
    "description": "The ID of the required ActiveGate.",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "jobId",
    "in": "path",
    "description": "A unique identifier for a update-job of ActiveGate.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/UpdateJob"
    }
    }
    }
    },
    "404": {
    "description": "Not found. See response body for details.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "delete": {
    "tags": [
    "ActiveGates - Auto-update jobs"
    ],
    "summary": "Deletes the specified update job",
    "operationId": "deleteUpdateJobByJobIdForAg",
    "parameters": [
    {
    "name": "agId",
    "in": "path",
    "description": "The ID of the required ActiveGate.",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "jobId",
    "in": "path",
    "description": "A unique identifier for a update-job of ActiveGate.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "204": {
    "description": "Success. The update-job have been deleted. Response doesn't have a body."
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    },
    "404": {
    "description": "Not found. See response body for details.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/activeGates/{agId}/updateJobs/validator": {
    "post": {
    "tags": [
    "ActiveGates - Auto-update jobs"
    ],
    "summary": "Validates the payload for the `POST /activeGates/{agId}/updateJobs` request.",
    "operationId": "validateUpdateJobForAg",
    "parameters": [
    {
    "name": "agId",
    "in": "path",
    "description": "The ID of the required ActiveGate.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "description": "JSON body of the request, containing update-job parameters.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/UpdateJob"
    }
    }
    },
    "required": true
    },
    "responses": {
    "204": {
    "description": "Validated. The submitted update-job is valid. Response doesn't have a body."
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/activeGates": {
    "get": {
    "tags": [
    "ActiveGates"
    ],
    "summary": "Lists all available ActiveGates",
    "description": "The response includes all ActiveGates that are currently connected to the environment or have been connected during last 2 hours.",
    "operationId": "getAllActiveGates",
    "parameters": [
    {
    "name": "hostname",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the name of the host it's running on. \n\n You can specify a partial name. In that case, the `CONTAINS` operator is used.",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "osType",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the OS type of the host it's running on.",
    "schema": {
    "type": "string",
    "enum": [
    "LINUX",
    "WINDOWS"
    ]
    }
    },
    {
    "name": "networkAddress",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the network address. \n\n You can specify a partial address. In that case, the `CONTAINS` operator is used.",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "loadBalancerAddress",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the Load Balancer address. \n\n You can specify a partial address. In that case, the `CONTAINS` operator is used.",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "type",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the ActiveGate type.",
    "schema": {
    "type": "string",
    "enum": [
    "ENVIRONMENT",
    "ENVIRONMENT_MULTI",
    "CLUSTER"
    ]
    }
    },
    {
    "name": "networkZone",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the network zone. \n\n You can specify a partial name. In that case, the `CONTAINS` operator is used.",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "updateStatus",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the auto-update status.",
    "schema": {
    "type": "string",
    "enum": [
    "INCOMPATIBLE",
    "OUTDATED",
    "SCHEDULED",
    "SUPPRESSED",
    "UNKNOWN",
    "UP2DATE",
    "UPDATE_IN_PROGRESS",
    "UPDATE_PENDING",
    "UPDATE_PROBLEM"
    ]
    }
    },
    {
    "name": "versionCompareType",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the specified version. \n\n Specify the comparison operator here.",
    "schema": {
    "type": "string",
    "enum": [
    "EQUAL",
    "GREATER",
    "GREATER_EQUAL",
    "LOWER",
    "LOWER_EQUAL"
    ],
    "default": "EQUAL"
    }
    },
    {
    "name": "version",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the specified version. \n\n Specify the version in `<major>.<minor>.<revision>` format (for example, `1.195.0`) here.",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "autoUpdate",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the actual state of auto-update.",
    "schema": {
    "type": "string",
    "enum": [
    "DISABLED",
    "ENABLED"
    ]
    }
    },
    {
    "name": "group",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the group. \n\n You can specify a partial name. In that case, the `CONTAINS` operator is used.",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "online",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the communication status.",
    "schema": {
    "type": "boolean"
    }
    },
    {
    "name": "enabledModule",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the enabled modules.",
    "schema": {
    "type": "array",
    "items": {
    "type": "string",
    "enum": [
    "AWS",
    "AZURE",
    "BEACON_FORWARDER",
    "CLOUD_FOUNDRY",
    "DB_INSIGHT",
    "EXTENSIONS_V1",
    "EXTENSIONS_V2",
    "KUBERNETES",
    "LOGS",
    "MEMORY_DUMPS",
    "METRIC_API",
    "ONE_AGENT_ROUTING",
    "OTLP_INGEST",
    "REST_API",
    "SYNTHETIC",
    "VMWARE",
    "Z_OS"
    ]
    }
    }
    },
    {
    "name": "disabledModule",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates by the disabled modules.",
    "schema": {
    "type": "array",
    "items": {
    "type": "string",
    "enum": [
    "AWS",
    "AZURE",
    "BEACON_FORWARDER",
    "CLOUD_FOUNDRY",
    "DB_INSIGHT",
    "EXTENSIONS_V1",
    "EXTENSIONS_V2",
    "KUBERNETES",
    "LOGS",
    "MEMORY_DUMPS",
    "METRIC_API",
    "ONE_AGENT_ROUTING",
    "OTLP_INGEST",
    "REST_API",
    "SYNTHETIC",
    "VMWARE",
    "Z_OS"
    ]
    }
    }
    },
    {
    "name": "containerized",
    "in": "query",
    "description": "Filters the resulting set of ActiveGates to those which are running in container (`true`) or not (`false`).",
    "schema": {
    "type": "boolean"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ActiveGateList"
    }
    }
    }
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/activeGates/{agId}": {
    "get": {
    "tags": [
    "ActiveGates"
    ],
    "summary": "Gets the details of the specified ActiveGate",
    "operationId": "getOneActiveGateById",
    "parameters": [
    {
    "name": "agId",
    "in": "path",
    "description": "The ID of the required ActiveGate.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ActiveGate"
    }
    }
    }
    },
    "404": {
    "description": "Not found. See response body for details.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/deployment/installer/gateway/versions/{osType}": {
    "get": {
    "tags": [
    "Deployment"
    ],
    "summary": "Lists all available versions of ActiveGate installer",
    "operationId": "getActiveGateInstallerAvailableVersions",
    "parameters": [
    {
    "name": "osType",
    "in": "path",
    "description": "The operating system of the installer.",
    "required": true,
    "schema": {
    "type": "string",
    "enum": [
    "windows",
    "unix"
    ]
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success. The payload contains the available versions.",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ActiveGateInstallerVersions"
    }
    }
    }
    },
    "404": {
    "description": "Not found. See the response body for details.",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/networkZones": {
    "get": {
    "tags": [
    "Network zones"
    ],
    "summary": "Lists all existing network zones | maturity=EARLY_ADOPTER",
    "operationId": "getAllNetworkZones",
    "parameters": [],
    "responses": {
    "200": {
    "description": "Success.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/NetworkZoneList"
    }
    }
    }
    }
    },
    "x-feature-flag": "NETWORK_ZONE_REST_API_RESOURCE",
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/networkZones/{id}": {
    "get": {
    "tags": [
    "Network zones"
    ],
    "summary": "Gets parameters of the specified network zone | maturity=EARLY_ADOPTER",
    "operationId": "getSingleNetworkZone",
    "parameters": [
    {
    "name": "id",
    "in": "path",
    "description": "The ID of the required network zone.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/NetworkZone"
    }
    }
    }
    }
    },
    "x-feature-flag": "NETWORK_ZONE_REST_API_RESOURCE",
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "put": {
    "tags": [
    "Network zones"
    ],
    "summary": "Updates an existing network zone or creates a new one | maturity=EARLY_ADOPTER",
    "description": "If the network zone with the specified ID does not exist, a new network zone is created. \n\n The ID is not case sensitive. Dynatrace stores the ID in lowercase.",
    "operationId": "createOrUpdateNetworkZone",
    "parameters": [
    {
    "name": "id",
    "in": "path",
    "description": "The ID of the network zone to be updated. \n\n If you set the ID in the body as well, it must match this ID. \n\n The ID is not case sensitive. Dynatrace stores the ID in lowercase.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "description": "The JSON body of the request. Contains parameters of the network zone.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/NetworkZone"
    }
    }
    },
    "required": true
    },
    "responses": {
    "201": {
    "description": "Success. The new network zone has been created. The response body contains the ID of the new network zone.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/EntityShortRepresentation"
    }
    }
    }
    },
    "204": {
    "description": "Success. The network zone has been updated. Response doesn't have a body."
    },
    "400": {
    "description": "Failed. The input is invalid.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-feature-flag": "NETWORK_ZONE_REST_API_RESOURCE",
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "delete": {
    "tags": [
    "Network zones"
    ],
    "summary": "Deletes the specified network zone | maturity=EARLY_ADOPTER",
    "description": "You can only delete an empty network zone (a zone that no ActiveGate or OneAgent is using). \n\n If the network zone is used as an alternative zone for any OneAgent, it will be automatically removed from the list of possible alternatives.",
    "operationId": "deleteNetworkZone",
    "parameters": [
    {
    "name": "id",
    "in": "path",
    "description": "The ID of the network zone to be deleted.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "204": {
    "description": "Deleted. Response doesn't have a body."
    },
    "400": {
    "description": "Failed. See error message in the response body for details.",
    "content": {
    "*/*": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-feature-flag": "NETWORK_ZONE_REST_API_RESOURCE",
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/tokens/{id}": {
    "get": {
    "tags": [
    "Tokens"
    ],
    "summary": "Lists token metadata by token ID",
    "description": "The token itself is **not** exposed.",
    "operationId": "getTokenMetadata",
    "parameters": [
    {
    "name": "id",
    "in": "path",
    "description": "The ID of the required token.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/TokenMetadata"
    }
    }
    }
    },
    "404": {
    "description": "Failed. The requested token has not been found.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ClusterTokenManagement` (Cluster token management)"
    ]
    },
    "put": {
    "tags": [
    "Tokens"
    ],
    "summary": "Updates the specified token",
    "operationId": "updateToken",
    "parameters": [
    {
    "name": "id",
    "in": "path",
    "description": "The ID of the token to be updated. \n\n You can't update the token you're using for authentication of the request.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "description": "The JSON body of the request. Contains updated parameters of the token.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/UpdateToken"
    }
    }
    },
    "required": true
    },
    "responses": {
    "204": {
    "description": "Success. The token has been updated."
    },
    "400": {
    "description": "Failed. You can't update the token you're using for authentication of the request.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    },
    "404": {
    "description": "Failed. The requested token has not been found.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ClusterTokenManagement` (Cluster token management)"
    ]
    },
    "delete": {
    "tags": [
    "Tokens"
    ],
    "summary": "Deletes the specified token",
    "operationId": "deleteToken",
    "parameters": [
    {
    "name": "id",
    "in": "path",
    "description": "The ID of the token to be deleted. Can either be the public identifier or the secret.\n\n You can't delete the token you're using for authentication of the request.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "204": {
    "description": "Success"
    },
    "400": {
    "description": "Failed. You can't delete the token you're using for authentication of the request.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    },
    "404": {
    "description": "Failed. The requested token has not been found.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ClusterTokenManagement` (Cluster token management)"
    ]
    }
    },
    "/tokens/lookup": {
    "post": {
    "tags": [
    "Tokens"
    ],
    "summary": "Lists token metadata by token itself",
    "operationId": "getTokenMetadataBySecret",
    "parameters": [],
    "requestBody": {
    "description": "The JSON body of the request. Contains the required token.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/Token"
    }
    }
    },
    "required": true
    },
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/TokenMetadata"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "Any Api-Token scope"
    ]
    }
    },
    "/tokens": {
    "get": {
    "tags": [
    "Tokens"
    ],
    "summary": "Lists available tokens in your environment",
    "description": "You can narrow down the output by adding parameters. The token has to match *all* the specified parameters. \n\n You can also specify the limit of returned tokens.\n\n **This list may contain tokens which were created automatically** (e.g. InstallerDownload, Mobile, ...) and are not visible on the `Settings` page. Deleting those might have unintended side-effects as they might still be in use.",
    "operationId": "listTokens",
    "parameters": [
    {
    "name": "limit",
    "in": "query",
    "description": "Limits the maximum number of returned tokens. \n\n If not set the value of `1000` is used. \n\n Maximum value is 1000000.",
    "schema": {
    "maximum": 1000000,
    "minimum": 0,
    "type": "integer",
    "format": "int32",
    "default": 1000
    }
    },
    {
    "name": "user",
    "in": "query",
    "description": "Filters the resulting set of tokens by user, who owns the token.",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "permissions",
    "in": "query",
    "description": "Filters the resulting set of tokens by scopes assigned to the token. \n\n You can specify several permissions in the following format: `permissions=scope1&permissions=scope2`. The token must have *all* the specified scopes.",
    "schema": {
    "uniqueItems": true,
    "type": "array",
    "items": {
    "type": "string",
    "enum": [
    "ClusterTokenManagement",
    "ControlManagement",
    "DiagnosticExport",
    "EnvironmentTokenManagement",
    "ExternalSyntheticIntegration",
    "Nodekeeper",
    "ReadSyntheticData",
    "ServiceProviderAPI",
    "UnattendedInstall",
    "apiTokens.read",
    "apiTokens.write",
    "settings.read",
    "settings.write"
    ]
    }
    }
    },
    {
    "name": "from",
    "in": "query",
    "description": "Last used after this timestamp (UTC milliseconds).",
    "schema": {
    "type": "integer",
    "format": "int64"
    }
    },
    {
    "name": "to",
    "in": "query",
    "description": "Last used before this timestamp (UTC milliseconds).",
    "schema": {
    "type": "integer",
    "format": "int64"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/StubList"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ClusterTokenManagement` (Cluster token management)"
    ]
    },
    "post": {
    "tags": [
    "Tokens"
    ],
    "summary": "Creates a new token",
    "description": "The newly created token will be owned by the same user who owns the token used for authentication of the call.",
    "operationId": "createToken",
    "parameters": [],
    "requestBody": {
    "description": "The JSON body of the request. Contains parameters of the new token.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/CreateToken"
    }
    }
    },
    "required": true
    },
    "responses": {
    "201": {
    "description": "Success. The token has been created. The response body contains the token itself.",
    "headers": {
    "Location": {
    "description": "Token Id",
    "style": "simple",
    "schema": {
    "type": "string"
    }
    }
    },
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/Token"
    }
    },
    "text/csv; header=present; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/Token"
    }
    },
    "text/csv; header=absent; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/Token"
    }
    },
    "text/plain; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/Token"
    }
    }
    }
    },
    "400": {
    "description": "Failed. The input is invalid. Response body provides details.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    },
    "text/csv; header=present; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    },
    "text/csv; header=absent; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    },
    "text/plain; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ClusterTokenManagement` (Cluster token management)"
    ]
    }
    },
    "/iam/configuration/policystatements": {
    "get": {
    "tags": [
    "IAM - configuration resource"
    ],
    "summary": "Gets configuration for policy statements. Available values for services, permissions, conditions and operators",
    "operationId": "getPolicyStatementConfiguration",
    "parameters": [
    {
    "name": "statuses",
    "in": "query",
    "schema": {
    "type": "array",
    "items": {
    "type": "string",
    "enum": [
    "GENERAL_AVAILABILITY",
    "IN_DEVELOPMENT"
    ]
    }
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Successful response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/StatementConfiguration"
    }
    }
    }
    }
    }
    }
    },
    "/iam/repo/{level-type}/{level-id}/bindings/groups/{group-uuid}": {
    "get": {
    "tags": [
    "IAM - policies bindings"
    ],
    "summary": "Get policy UUIDs for a given level by level ID and group",
    "operationId": "getPolicyUuids",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "group-uuid",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Successful response - level found",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/PolicyUuids"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "put": {
    "tags": [
    "IAM - policies bindings"
    ],
    "summary": "Create or update policy bindings within a level for a group",
    "operationId": "replace",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "group-uuid",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/CreateOrUpdateGroupBindings"
    }
    }
    },
    "required": true
    },
    "responses": {
    "204": {
    "description": "Successful response - policy bindings created or updated"
    },
    "400": {
    "description": "Policy bindings create or update request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "422": {
    "description": "Policy bindings create or update request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/iam/repo/{level-type}/{level-id}/bindings": {
    "get": {
    "tags": [
    "IAM - policies bindings"
    ],
    "summary": "Get policy bindings for a level",
    "operationId": "getAll",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Successful response - level found",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/LevelPolicyBindingsList"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "put": {
    "tags": [
    "IAM - policies bindings"
    ],
    "summary": "Update policy bindings within a level",
    "operationId": "replace_1",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/CreateLevelPolicyBindingsRequest"
    }
    }
    },
    "required": true
    },
    "responses": {
    "204": {
    "description": "Successful response - policy bindings created or updated"
    },
    "400": {
    "description": "Policy bindings create or update request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "422": {
    "description": "Policy bindings create or update request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "delete": {
    "tags": [
    "IAM - policies bindings"
    ],
    "summary": "Delete all policy bindings from a level",
    "operationId": "delete_2",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "204": {
    "description": "Successful response - bindings deleted"
    },
    "400": {
    "description": "Policy bindings delete request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "422": {
    "description": "Policy bindings delete request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/iam/repo/{level-type}/{level-id}/bindings/{policy-uuid}": {
    "post": {
    "tags": [
    "IAM - policies bindings"
    ],
    "summary": "Append policy bindings within a level",
    "operationId": "append",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "policy-uuid",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string",
    "format": "uuid"
    }
    }
    ],
    "requestBody": {
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/AppendLevelPolicyBindingsRequest"
    }
    }
    },
    "required": true
    },
    "responses": {
    "204": {
    "description": "Successful response - policy bindings created or updated"
    },
    "400": {
    "description": "Policy bindings create or update request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "422": {
    "description": "Policy bindings create or update request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "delete": {
    "tags": [
    "IAM - policies bindings"
    ],
    "summary": "Delete all policy bindings within a level",
    "operationId": "delete_1",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "policy-uuid",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string",
    "format": "uuid"
    }
    }
    ],
    "responses": {
    "204": {
    "description": "Successful response - binding deleted"
    },
    "400": {
    "description": "Policy bindings delete request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/iam/repo/{level-type}/{level-id}/bindings/{policy-uuid}/{group-uuid}": {
    "delete": {
    "tags": [
    "IAM - policies bindings"
    ],
    "summary": "Delete a policy binding from a group within a level",
    "operationId": "delete",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "policy-uuid",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string",
    "format": "uuid"
    }
    },
    {
    "name": "group-uuid",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "204": {
    "description": "Successful response - binding deleted"
    },
    "400": {
    "description": "Policy bindings delete request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/iam/repo/{level-type}/{level-id}/policies/aggregate": {
    "get": {
    "tags": [
    "IAM - policies management"
    ],
    "summary": "Get overview of all policies for a given level, descendant and ancestor levels",
    "operationId": "getPolicyOverviewList",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Successful response - level found",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/PolicyOverviewList"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ControlManagement` (ControlManagement)",
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/iam/repo/{level-type}/{level-id}/policies": {
    "get": {
    "tags": [
    "IAM - policies management"
    ],
    "summary": "Get all policies for a level",
    "operationId": "getAll_1",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "name",
    "in": "query",
    "description": "Optional policy name. Only policies that are of equal name will be returned",
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Successful response - level found",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/LevelPoliciesBasicDataList"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ControlManagement` (ControlManagement)",
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "post": {
    "tags": [
    "IAM - policies management"
    ],
    "summary": "Create a policy within a level",
    "operationId": "create",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/CreateOrUpdateLevelPolicyRequest"
    }
    }
    },
    "required": true
    },
    "responses": {
    "201": {
    "description": "Successful response - policy created",
    "headers": {
    "Location": {
    "description": "URI of created policy",
    "style": "simple"
    }
    },
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/Policy"
    }
    }
    }
    },
    "400": {
    "description": "Policy create request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "422": {
    "description": "Policy create request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/iam/repo/{level-type}/{level-id}/policies/{uuid}": {
    "get": {
    "tags": [
    "IAM - policies management"
    ],
    "summary": "Get a policy within a level",
    "operationId": "get",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "uuid",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string",
    "format": "uuid"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Successful response - policy found",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/Policy"
    }
    }
    }
    },
    "404": {
    "description": "Policy not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ControlManagement` (ControlManagement)",
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "put": {
    "tags": [
    "IAM - policies management"
    ],
    "summary": "Update or create a new policy within a level",
    "operationId": "put",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "uuid",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string",
    "format": "uuid"
    }
    }
    ],
    "requestBody": {
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/CreateOrUpdateLevelPolicyRequest"
    }
    }
    },
    "required": true
    },
    "responses": {
    "201": {
    "description": "Successful response - policy created",
    "headers": {
    "Location": {
    "description": "URI of created policy",
    "style": "simple"
    }
    },
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/Policy"
    }
    }
    }
    },
    "204": {
    "description": "Successful response - policy updated"
    },
    "400": {
    "description": "Policy put request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "422": {
    "description": "Policy put request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "delete": {
    "tags": [
    "IAM - policies management"
    ],
    "summary": "Delete a policy from a level",
    "operationId": "delete_3",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "uuid",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string",
    "format": "uuid"
    }
    },
    {
    "name": "force",
    "in": "query",
    "schema": {
    "type": "boolean",
    "default": true
    }
    }
    ],
    "responses": {
    "204": {
    "description": "Successful response - policy deleted"
    },
    "400": {
    "description": "Policy delete request invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/iam/repo/{level-type}/{level-id}/policies/validation": {
    "post": {
    "tags": [
    "IAM - policies management"
    ],
    "summary": "Validates policy before creation or update",
    "operationId": "validate",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/CreateOrUpdateLevelPolicyRequest"
    }
    }
    },
    "required": true
    },
    "responses": {
    "200": {
    "description": "Policy is valid but there may be some validation warnings. Please check the response body",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ValidationWarnings"
    }
    }
    }
    },
    "400": {
    "description": "Policy request is invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "422": {
    "description": "Policy request is invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/iam/repo/{level-type}/{level-id}/policies/validation/{policy-uuid}": {
    "post": {
    "tags": [
    "IAM - policies management"
    ],
    "summary": "Validates policy before creation or update",
    "operationId": "validate_1",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "policy-uuid",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string",
    "format": "uuid"
    }
    }
    ],
    "requestBody": {
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/CreateOrUpdateLevelPolicyRequest"
    }
    }
    },
    "required": true
    },
    "responses": {
    "200": {
    "description": "Policy is valid but there may be some validation warnings. Please check the response body",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ValidationWarnings"
    }
    }
    }
    },
    "400": {
    "description": "Policy request is invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    },
    "422": {
    "description": "Policy request is invalid",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/iam/organizational-levels/{level-type}/{level-id}/descendants": {
    "get": {
    "tags": [
    "IAM - organizational levels"
    ],
    "summary": "Get descendant organizational levels for a given level by level ID",
    "operationId": "getDescendants",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Successful response - level list",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/LevelList"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ControlManagement` (ControlManagement)",
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/iam/organizational-levels/{level-type}/{level-id}": {
    "get": {
    "tags": [
    "IAM - organizational levels"
    ],
    "summary": "Get an organizational level by level ID",
    "operationId": "get_1",
    "parameters": [
    {
    "name": "level-type",
    "in": "path",
    "description": "One of the values: global, cluster, environment",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "level-id",
    "in": "path",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Successful response - level found",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/Level"
    }
    }
    }
    },
    "404": {
    "description": "Level not found response",
    "content": {
    "application/json": {
    "schema": {
    "$ref": "#/components/schemas/ErrorMessage"
    }
    }
    }
    }
    },
    "security": [
    {
    "Api-Token": []
    }
    ],
    "x-token-scopes": [
    "`ControlManagement` (ControlManagement)",
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/settings/objects": {
    "get": {
    "tags": [
    "Settings - Objects"
    ],
    "summary": "Lists available settings objects | maturity=EARLY_ADOPTER",
    "operationId": "getSettingsObjects",
    "parameters": [
    {
    "name": "schemaIds",
    "in": "query",
    "description": "A list of comma-separated schema IDs to which the requested objects belong. \n\nTo load the first page, when the **nextPageKey** is not set, this parameter is required. ",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "scopes",
    "in": "query",
    "description": "A list of comma-separated scopes, that the requested objects target. \n\nThe selection only matches objects directly targeting the specified scopes. For example, `environment` will not match objects that target a host within environment. \n\nTo load the first page, when the **nextPageKey** is not set, this parameter is required. ",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "fields",
    "in": "query",
    "description": "A list of fields to be included to the response. The provided set of fields replaces the default set. \n\n Specify the required top-level fields, separated by commas (for example, `objectId,value`).",
    "schema": {
    "type": "string",
    "default": "objectId,value"
    }
    },
    {
    "name": "nextPageKey",
    "in": "query",
    "description": "The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response. \n\nThe first page is always returned if you don't specify the **nextPageKey** query parameter. \n\nWhen the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters. ",
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "pageSize",
    "in": "query",
    "description": "The amount of settings objects in a single response payload. \n\nThe maximal allowed page size is 500. \n\nIf not set, 100 is used.",
    "schema": {
    "type": "integer",
    "format": "int64"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ObjectsList"
    }
    }
    }
    },
    "404": {
    "description": "Failed. The specified schema or scope is not found.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-feature-flag": "SETTINGS_PUBLIC_REST_API_V2",
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`settings.read` (Read settings)"
    ],
    "x-supports-personal-access-token": true
    },
    "post": {
    "tags": [
    "Settings - Objects"
    ],
    "summary": "Creates a new settings object | maturity=EARLY_ADOPTER",
    "description": "You can upload several objects at once. In that case each object returns its own response code. Check the response body for details.",
    "operationId": "postSettingsObjects",
    "parameters": [
    {
    "name": "validateOnly",
    "in": "query",
    "description": "If `true`, the request runs only validation of the submitted settings objects, without saving them.",
    "schema": {
    "type": "boolean",
    "default": false
    }
    }
    ],
    "requestBody": {
    "description": "The JSON body of the request. Contains the settings objects.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/SettingsObjectCreate"
    }
    }
    }
    }
    },
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/SettingsObjectResponse"
    }
    }
    }
    }
    },
    "207": {
    "description": "Multi-status: different objects in the payload resulted in different statuses.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/SettingsObjectResponse"
    }
    }
    }
    }
    },
    "400": {
    "description": "Failed. Schema validation failed.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/SettingsObjectResponse"
    }
    }
    }
    }
    },
    "404": {
    "description": "Failed. The requested resource doesn't exist.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/SettingsObjectResponse"
    }
    }
    }
    }
    },
    "409": {
    "description": "Failed. Conflicting resource.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/SettingsObjectResponse"
    }
    }
    }
    }
    }
    },
    "x-feature-flag": "SETTINGS_PUBLIC_REST_API_V2",
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`settings.write` (Write settings)"
    ],
    "x-supports-personal-access-token": true
    }
    },
    "/settings/objects/{objectId}": {
    "get": {
    "tags": [
    "Settings - Objects"
    ],
    "summary": "Gets the specified settings object | maturity=EARLY_ADOPTER",
    "operationId": "getSettingsObjectByObjectId",
    "parameters": [
    {
    "name": "objectId",
    "in": "path",
    "description": "The ID of the required settings object.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SettingsObject"
    }
    }
    }
    },
    "404": {
    "description": "No object available for the given objectId",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SettingsObjectResponse"
    }
    }
    }
    }
    },
    "x-feature-flag": "SETTINGS_PUBLIC_REST_API_V2",
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`settings.read` (Read settings)"
    ],
    "x-supports-personal-access-token": true
    },
    "put": {
    "tags": [
    "Settings - Objects"
    ],
    "summary": "Updates an existing settings object | maturity=EARLY_ADOPTER",
    "operationId": "putSettingsObjectByObjectId",
    "parameters": [
    {
    "name": "objectId",
    "in": "path",
    "description": "The ID of the required settings object.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "description": "The JSON body of the request. Contains updated parameters of the settings object.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SettingsObjectUpdate"
    }
    }
    }
    },
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SettingsObjectResponse"
    }
    }
    }
    },
    "400": {
    "description": "Failed. Schema validation failed.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SettingsObjectResponse"
    }
    }
    }
    },
    "404": {
    "description": "Failed. The requested resource doesn't exist.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SettingsObjectResponse"
    }
    }
    }
    },
    "409": {
    "description": "Failed. Conflicting resource.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SettingsObjectResponse"
    }
    }
    }
    }
    },
    "x-feature-flag": "SETTINGS_PUBLIC_REST_API_V2",
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`settings.write` (Write settings)"
    ],
    "x-supports-personal-access-token": true
    },
    "delete": {
    "tags": [
    "Settings - Objects"
    ],
    "summary": "Deletes the specified settings object | maturity=EARLY_ADOPTER",
    "operationId": "deleteSettingsObjectByObjectId",
    "parameters": [
    {
    "name": "objectId",
    "in": "path",
    "description": "The ID of the required settings object.",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "updateToken",
    "in": "query",
    "description": "The update token of the object. You can use it to detect simultaneous modifications by different users. \n\nIt is generated upon retrieval (GET requests). If set on update (PUT request) or deletion, the update/deletion will be allowed only if there wasn't any change between the retrieval and the update. \n\nIf omitted on update/deletion, the operation overrides the current value or deletes it without any checks.",
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "204": {
    "description": "Success. Response doesn't have a body."
    },
    "404": {
    "description": "Failed. The requested resource doesn't exist.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SettingsObjectResponse"
    }
    }
    }
    },
    "409": {
    "description": "Failed. Conflicting resource.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SettingsObjectResponse"
    }
    }
    }
    }
    },
    "x-feature-flag": "SETTINGS_PUBLIC_REST_API_V2",
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`settings.write` (Write settings)"
    ],
    "x-supports-personal-access-token": true
    }
    },
    "/settings/schemas": {
    "get": {
    "tags": [
    "Settings - Schemas"
    ],
    "summary": "Lists available settings schemas | maturity=EARLY_ADOPTER",
    "operationId": "getAvailableSchemaDefinitions",
    "parameters": [],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SchemaList"
    }
    }
    }
    }
    },
    "x-feature-flag": "SETTINGS_PUBLIC_REST_API_V2",
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`settings.read` (Read settings)"
    ],
    "x-supports-personal-access-token": true
    }
    },
    "/settings/schemas/{schemaId}": {
    "get": {
    "tags": [
    "Settings - Schemas"
    ],
    "summary": "Gets parameters of the specified settings schema | maturity=EARLY_ADOPTER",
    "operationId": "getSchemaDefinition",
    "parameters": [
    {
    "name": "schemaId",
    "in": "path",
    "description": "The ID of the required schema.",
    "required": true,
    "schema": {
    "type": "string"
    }
    },
    {
    "name": "schemaVersion",
    "in": "query",
    "description": "The version of the required schema. \n\n If not set, the most recent version is returned.",
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SchemaDefinitionRestDto"
    }
    }
    }
    },
    "404": {
    "description": "Failed. The specified schema doesn't exist.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/ErrorEnvelope"
    }
    }
    }
    }
    },
    "x-feature-flag": "SETTINGS_PUBLIC_REST_API_V2",
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`settings.read` (Read settings)"
    ],
    "x-supports-personal-access-token": true
    }
    },
    "/synthetic/locations": {
    "get": {
    "tags": [
    "Synthetic - Locations, nodes and configuration"
    ],
    "summary": "Lists all cluster private synthetic locations",
    "operationId": "getLocations",
    "parameters": [],
    "responses": {
    "200": {
    "description": "Success.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SyntheticLocations"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "post": {
    "tags": [
    "Synthetic - Locations, nodes and configuration"
    ],
    "summary": "Creates a new private synthetic cluster location",
    "operationId": "addLocation",
    "parameters": [],
    "requestBody": {
    "description": "The JSON body of the request. Contains parameters of the new private synthetic cluster location",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/PrivateSyntheticLocation"
    }
    }
    }
    },
    "responses": {
    "200": {
    "description": "Success.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SyntheticLocationIdsDto"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/synthetic/locations/{locationId}": {
    "get": {
    "tags": [
    "Synthetic - Locations, nodes and configuration"
    ],
    "summary": "Gets properties of the specified cluster location",
    "operationId": "getLocation",
    "parameters": [
    {
    "name": "locationId",
    "in": "path",
    "description": "The Dynatrace entity ID of the required cluster location.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success. The response contains parameters of the synthetic cluster location.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/SyntheticLocation"
    }
    }
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "put": {
    "tags": [
    "Synthetic - Locations, nodes and configuration"
    ],
    "summary": "Updates the specified private synthetic cluster location",
    "operationId": "updateLocation",
    "parameters": [
    {
    "name": "locationId",
    "in": "path",
    "description": "The Dynatrace entity ID of the private synthetic cluster location to be updated.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "requestBody": {
    "description": "The JSON body of the request. Contains updated parameters of the private synthetic cluster location.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/PrivateSyntheticLocation"
    }
    }
    }
    },
    "responses": {
    "default": {
    "description": "default response",
    "content": {
    "application/json; charset=utf-8": {}
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    },
    "delete": {
    "tags": [
    "Synthetic - Locations, nodes and configuration"
    ],
    "summary": "Deletes the specified private synthetic cluster location",
    "operationId": "removeLocation",
    "parameters": [
    {
    "name": "locationId",
    "in": "path",
    "description": "The Dynatrace entity ID of the private synthetic cluster location to be deleted.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "default": {
    "description": "default response",
    "content": {
    "application/json; charset=utf-8": {}
    }
    }
    },
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/synthetic/nodes/{nodeId}": {
    "get": {
    "tags": [
    "Synthetic - Locations, nodes and configuration"
    ],
    "summary": "Lists properties of the specified synthetic cluster node | maturity=EARLY_ADOPTER",
    "operationId": "getNode",
    "parameters": [
    {
    "name": "nodeId",
    "in": "path",
    "description": "The ID of the required synthetic cluster node.",
    "required": true,
    "schema": {
    "type": "string"
    }
    }
    ],
    "responses": {
    "200": {
    "description": "Success.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/Node"
    }
    }
    }
    }
    },
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    },
    "/synthetic/nodes": {
    "get": {
    "tags": [
    "Synthetic - Locations, nodes and configuration"
    ],
    "summary": "Lists all synthetic cluster nodes | maturity=EARLY_ADOPTER",
    "operationId": "getNodes",
    "parameters": [],
    "responses": {
    "200": {
    "description": "Success.",
    "content": {
    "application/json; charset=utf-8": {
    "schema": {
    "$ref": "#/components/schemas/Nodes"
    }
    }
    }
    }
    },
    "x-maturity": "EARLY_ADOPTER",
    "x-token-scopes": [
    "`ServiceProviderAPI` (Service Provider API)"
    ]
    }
    }
    },
    "components": {
    "schemas": {
    "AgentUsageDto": {
    "type": "object",
    "properties": {
    "networkTraffic": {
    "type": "integer",
    "format": "int64"
    },
    "agentId": {
    "type": "integer",
    "format": "int32"
    },
    "agentTypeId": {
    "type": "integer",
    "format": "int32"
    },
    "agentUsageRecords": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/AgentUsageRecordDto"
    }
    }
    }
    },
    "AgentUsageRecordDto": {
    "type": "object",
    "properties": {
    "startTime": {
    "type": "string",
    "format": "date-time"
    },
    "endTime": {
    "type": "string",
    "format": "date-time"
    }
    }
    },
    "BillingRequestDto": {
    "type": "object",
    "properties": {
    "clusterUuid": {
    "type": "string"
    },
    "timeFrameStart": {
    "type": "string",
    "format": "date-time"
    },
    "timeFrameEnd": {
    "type": "string",
    "format": "date-time"
    },
    "environmentBillingEntries": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/EnvironmentUsageDto"
    }
    }
    }
    },
    "CustomMetricDto": {
    "type": "object",
    "properties": {
    "source": {
    "type": "string"
    },
    "total": {
    "type": "integer",
    "format": "int64"
    }
    }
    },
    "DavisDataUnitsUsageDto": {
    "type": "object",
    "properties": {
    "pool": {
    "type": "string"
    },
    "total": {
    "type": "number"
    }
    }
    },
    "DownloadsDto": {
    "type": "object",
    "properties": {
    "type": {
    "type": "string"
    },
    "downloadCount": {
    "type": "integer",
    "format": "int32"
    },
    "version": {
    "type": "string"
    },
    "firstDownloadTime": {
    "type": "string",
    "format": "date-time"
    }
    }
    },
    "EnvironmentUsageDto": {
    "type": "object",
    "properties": {
    "environmentUuid": {
    "type": "string"
    },
    "visits": {
    "type": "integer",
    "format": "int64"
    },
    "mobileSessions": {
    "type": "integer",
    "format": "int64"
    },
    "totalRUMUserPropertiesUsed": {
    "type": "integer",
    "format": "int64"
    },
    "newProblems": {
    "type": "integer",
    "format": "int64"
    },
    "hostUsages": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/HostUsageDto"
    }
    },
    "downloads": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/DownloadsDto"
    }
    },
    "syntheticUsages": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/SyntheticUsageDto"
    }
    },
    "syntheticBillingUsage": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/SyntheticBillingUsageDto"
    }
    },
    "customMetrics": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/CustomMetricDto"
    }
    },
    "davisDataUnits": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/DavisDataUnitsUsageDto"
    }
    },
    "trial": {
    "type": "boolean"
    },
    "internalUse": {
    "type": "boolean"
    },
    "highAvailabilityCluster": {
    "type": "boolean"
    },
    "logStorageUsageBytes": {
    "type": "integer",
    "format": "int64"
    },
    "logUploadVolumeBytes": {
    "type": "integer",
    "format": "int64"
    },
    "sessionReplays": {
    "type": "integer",
    "format": "int64"
    },
    "mobileSessionReplays": {
    "type": "integer",
    "format": "int64"
    }
    }
    },
    "HostUsageDto": {
    "type": "object",
    "properties": {
    "osiId": {
    "type": "integer",
    "format": "int64"
    },
    "hostName": {
    "type": "string"
    },
    "hostCategory": {
    "type": "string"
    },
    "agentUsages": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/AgentUsageDto"
    }
    },
    "infrastructureOnly": {
    "type": "boolean"
    },
    "paas": {
    "type": "boolean"
    },
    "passMemoryLimit": {
    "type": "integer",
    "format": "int64"
    },
    "vendorTypeId": {
    "type": "integer",
    "format": "int32"
    },
    "hostMemoryBytes": {
    "type": "integer",
    "format": "int64"
    },
    "premiumLogAnalytics": {
    "type": "boolean"
    },
    "hasContainers": {
    "type": "boolean"
    }
    }
    },
    "SyntheticBillingUsageDto": {
    "type": "object",
    "properties": {
    "monitorTypeId": {
    "type": "integer",
    "format": "int32"
    },
    "testId": {
    "type": "integer",
    "format": "int64"
    },
    "publicExecutions": {
    "type": "integer",
    "format": "int64"
    },
    "privateExecutions": {
    "type": "integer",
    "format": "int64"
    }
    }
    },
    "SyntheticUsageDto": {
    "type": "object",
    "properties": {
    "monitorDefinitionId": {
    "type": "string"
    },
    "monitorDescription": {
    "type": "string"
    },
    "monitorTypeId": {
    "type": "integer",
    "format": "int32"
    },
    "successCount": {
    "type": "integer",
    "format": "int32"
    },
    "failureCount": {
    "type": "integer",
    "format": "int32"
    },
    "syntheticActionCount": {
    "type": "integer",
    "format": "int32"
    },
    "performedSyntheticActions": {
    "type": "integer",
    "format": "int32"
    }
    }
    },
    "CustomMetricsQuota": {
    "type": "object",
    "properties": {
    "maxLimit": {
    "type": "integer",
    "description": "Concurrent environment quota. Not set if unlimited. When updating via PUT method, skipping this field will set quota unlimited.",
    "format": "int64"
    },
    "currentUsage": {
    "type": "number",
    "description": "Current environment usage.",
    "format": "double",
    "readOnly": true
    }
    },
    "description": "Custom metrics consumption and quota information on environment level. Not set (and not editable) if Custom metrics is not enabled. Not set (and not editable) if Davis data units is enabled. If skipped when editing via PUT method then already set quota will remain."
    },
    "DavisDataUnitsQuota": {
    "type": "object",
    "properties": {
    "consumedThisMonth": {
    "type": "number",
    "description": "Monthly environment consumption. Resets each calendar month.",
    "format": "double",
    "readOnly": true
    },
    "consumedThisYear": {
    "type": "number",
    "description": "Yearly environment consumption. Resets each year on license creation date anniversary.",
    "format": "double",
    "readOnly": true
    },
    "monthlyLimit": {
    "type": "integer",
    "description": "Monthly environment quota. Not set if unlimited. When updating via PUT method, skipping this field will set quota unlimited.",
    "format": "int64"
    },
    "annualLimit": {
    "type": "integer",
    "description": "Annual environment quota. Not set if unlimited. When updating via PUT method, skipping this field will set quota unlimited.",
    "format": "int64"
    }
    },
    "description": "Davis data units consumption and quota information on environment level. Not set (and not editable) if Davis data units is not enabled. If skipped when editing via PUT method then already set quotas will remain."
    },
    "DemUnitsQuota": {
    "type": "object",
    "properties": {
    "consumedThisMonth": {
    "type": "number",
    "description": "Monthly environment consumption. Resets each calendar month.",
    "format": "double",
    "readOnly": true
    },
    "consumedThisYear": {
    "type": "number",
    "description": "Yearly environment consumption. Resets each year on license creation date anniversary.",
    "format": "double",
    "readOnly": true
    },
    "monthlyLimit": {
    "type": "integer",
    "description": "Monthly environment quota. Not set if unlimited. When updating via PUT method, skipping this field will set quota unlimited.",
    "format": "int64"
    },
    "annualLimit": {
    "type": "integer",
    "description": "Annual environment quota. Not set if unlimited. When updating via PUT method, skipping this field will set quota unlimited.",
    "format": "int64"
    }
    },
    "description": "DEM units consumption and quota information on environment level. Not set (and not editable) if DEM units is not enabled. If skipped when editing via PUT method then already set quotas will remain."
    },
    "Environment": {
    "required": [
    "name"
    ],
    "type": "object",
    "properties": {
    "name": {
    "maxLength": 100,
    "minLength": 1,
    "type": "string",
    "description": "The display name of the environment."
    },
    "id": {
    "type": "string",
    "description": "The ID of the environment. Has to match [a-zA-Z0-9_-]{1,70}"
    },
    "trial": {
    "type": "boolean",
    "description": "Specifies whether the environment is a trial environment or a non-trial environment. Creating a trial environment is only possible if your license allows that. The default value is false (non-trial)."
    },
    "state": {
    "type": "string",
    "description": "Indicates whether the environment is enabled or disabled. The default value is ENABLED.",
    "enum": [
    "DISABLED",
    "ENABLED"
    ]
    },
    "tags": {
    "maxItems": 1024,
    "minItems": 0,
    "uniqueItems": true,
    "type": "array",
    "description": "A set of tags that are assigned to this environment. Every tag can have a maximum length of 100 characters.",
    "items": {
    "type": "string"
    }
    },
    "creationDate": {
    "type": "string",
    "description": "The creation date of the environment in ISO 8601 format (yyyy-MM-dd'T'HH:mm:ss.SSS'Z')",
    "readOnly": true
    },
    "quotas": {
    "$ref": "#/components/schemas/EnvironmentQuotas"
    },
    "storage": {
    "$ref": "#/components/schemas/EnvironmentStorage"
    }
    },
    "description": "Basic configuration for an environment.",
    "example": {
    "name": "example environment",
    "state": "ENABLED",
    "tags": [
    "tag1",
    "tag2"
    ],
    "trial": false
    }
    },
    "EnvironmentQuotas": {
    "type": "object",
    "properties": {
    "hostUnits": {
    "$ref": "#/components/schemas/HostUnitQuota"
    },
    "demUnits": {
    "$ref": "#/components/schemas/DemUnitsQuota"
    },
    "userSessions": {
    "$ref": "#/components/schemas/UserSessionsQuota"
    },
    "sessionProperties": {
    "$ref": "#/components/schemas/SessionPropertiesQuota"
    },
    "syntheticMonitors": {
    "$ref": "#/components/schemas/SyntheticQuota"
    },
    "customMetrics": {
    "$ref": "#/components/schemas/CustomMetricsQuota"
    },
    "davisDataUnits": {
    "$ref": "#/components/schemas/DavisDataUnitsQuota"
    },
    "logMonitoring": {
    "$ref": "#/components/schemas/LogMonitoringQuota"
    }
    },
    "description": "Environment level consumption and quotas information. Only returned if includeConsumptionInfo or includeUncachedConsumptionInfo param is true. If skipped when editing via PUT method then already set quotas will remain."
    },
    "EnvironmentStorage": {
    "type": "object",
    "properties": {
    "transactionStorage": {
    "$ref": "#/components/schemas/TransactionStorage"
    },
    "sessionReplayStorage": {
    "$ref": "#/components/schemas/SessionReplayStorage"
    },
    "symbolFilesFromMobileApps": {
    "$ref": "#/components/schemas/SymbolFilesFromMobileApps"
    },
    "logMonitoringStorage": {
    "$ref": "#/components/schemas/LogMonitoringStorage"
    },
    "serviceRequestLevelRetention": {
    "$ref": "#/components/schemas/ServiceRequestLevelRetention"
    },
    "serviceCodeLevelRetention": {
    "$ref": "#/components/schemas/ServiceCodeLevelRetention"
    },
    "realUserMonitoringRetention": {
    "$ref": "#/components/schemas/RealUserMonitoringRetention"
    },
    "syntheticMonitoringRetention": {
    "$ref": "#/components/schemas/SyntheticMonitoringRetention"
    },
    "sessionReplayRetention": {
    "$ref": "#/components/schemas/SessionReplayRetention"
    },
    "logMonitoringRetention": {
    "$ref": "#/components/schemas/LogMonitoringRetention"
    },
    "userActionsPerMinute": {
    "$ref": "#/components/schemas/UserActionsPerMinute"
    },
    "transactionTrafficQuota": {
    "$ref": "#/components/schemas/TransactionTrafficQuota"
    }
    },
    "description": "Environment level storage usage and limit information. Not returned if includeStorageInfo param is not true. If skipped when editing via PUT method then already set limits will remain."
    },
    "HostUnitQuota": {
    "type": "object",
    "properties": {
    "maxLimit": {
    "type": "integer",
    "description": "Concurrent environment quota. Not set if unlimited. When updating via PUT method, skipping this field will set quota unlimited.",
    "format": "int64"
    },
    "currentUsage": {
    "type": "number",
    "description": "Current environment usage.",
    "format": "double",
    "readOnly": true
    }
    },
    "description": "Host units consumption and quota information on environment level. If skipped when editing via PUT method then already set quota will remain."
    },
    "LogMonitoringQuota": {
    "type": "object",
    "properties": {
    "consumedThisMonth": {
    "type": "number",
    "description": "Monthly environment consumption. Resets each calendar month.",
    "format": "double",
    "readOnly": true
    },
    "consumedThisYear": {
    "type": "number",
    "description": "Yearly environment consumption. Resets each year on license creation date anniversary.",
    "format": "double",
    "readOnly": true
    },
    "monthlyLimit": {
    "type": "integer",
    "description": "Monthly environment quota. Not set if unlimited. When updating via PUT method, skipping this field will set quota unlimited.",
    "format": "int64"
    },
    "annualLimit": {
    "type": "integer",
    "description": "Annual environment quota. Not set if unlimited. When updating via PUT method, skipping this field will set quota unlimited.",
    "format": "int64"
    }
    },
    "description": "Log monitoring consumption and quota information on environment level. Not set (and not editable) if Log monitoring is not enabled. Not set (and not editable) if Log monitoring is migrated to Davis data on license level. If skipped when editing via PUT method then already set quotas will remain."
    },
    "LogMonitoringRetention": {
    "type": "object",
    "properties": {
    "maxLimitInDays": {
    "type": "integer",
    "description": "Maximum retention limit [days]",
    "format": "int64"
    },
    "currentlyUsedInMillis": {
    "type": "integer",
    "description": "Current data age [milliseconds]",
    "format": "int64",
    "readOnly": true
    },
    "currentlyUsedInDays": {
    "type": "integer",
    "description": "Current data age [days]",
    "format": "int64",
    "readOnly": true
    }
    },
    "description": "Log monitoring retention settings on environment level. Not editable when Log monitoring is not allowed by license or not configured on cluster level. Can be set to any value from 5 to 90 days. If skipped when editing via PUT method then already set limit will remain."
    },
    "LogMonitoringStorage": {
    "type": "object",
    "properties": {
    "maxLimit": {
    "type": "integer",
    "description": "Maximum storage limit [bytes]",
    "format": "int64"
    },
    "currentlyUsed": {
    "type": "integer",
    "description": "Currently used storage [bytes]",
    "format": "int64",
    "readOnly": true
    }
    },
    "description": "Log monitoring storage usage and limit information on environment level. Not editable when Log monitoring is not allowed by license or not configured on cluster level. If skipped when editing via PUT method then already set limit will remain."
    },
    "RealUserMonitoringRetention": {
    "type": "object",
    "properties": {
    "maxLimitInDays": {
    "type": "integer",
    "description": "Maximum retention limit [days]",
    "format": "int64"
    },
    "currentlyUsedInMillis": {
    "type": "integer",
    "description": "Current data age [milliseconds]",
    "format": "int64",
    "readOnly": true
    },
    "currentlyUsedInDays": {
    "type": "integer",
    "description": "Current data age [days]",
    "format": "int64",
    "readOnly": true
    }
    },
    "description": "Real user monitoring retention settings on environment level. Can be set to any value from 1 to 35 days. If skipped when editing via PUT method then already set limit will remain."
    },
    "ServiceCodeLevelRetention": {
    "type": "object",
    "properties": {
    "maxLimitInDays": {
    "type": "integer",
    "description": "Maximum retention limit [days]",
    "format": "int64"
    },
    "currentlyUsedInMillis": {
    "type": "integer",
    "description": "Current data age [milliseconds]",
    "format": "int64",
    "readOnly": true
    },
    "currentlyUsedInDays": {
    "type": "integer",
    "description": "Current data age [days]",
    "format": "int64",
    "readOnly": true
    }
    },
    "description": "Service code level retention settings on environment level. Service code level retention time can't be greater than service request level retention time and both can't exceed one year.If skipped when editing via PUT method then already set limit will remain."
    },
    "ServiceRequestLevelRetention": {
    "type": "object",
    "properties": {
    "maxLimitInDays": {
    "type": "integer",
    "description": "Maximum retention limit [days]",
    "format": "int64"
    },
    "currentlyUsedInMillis": {
    "type": "integer",
    "description": "Current data age [milliseconds]",
    "format": "int64",
    "readOnly": true
    },
    "currentlyUsedInDays": {
    "type": "integer",
    "description": "Current data age [days]",
    "format": "int64",
    "readOnly": true
    }
    },
    "description": "Service request level retention settings on environment level. Service code level retention time can't be greater than service request level retention time and both can't exceed one year.If skipped when editing via PUT method then already set limit will remain."
    },
    "SessionPropertiesQuota": {
    "type": "object",
    "properties": {
    "consumedThisMonth": {
    "type": "number",
    "description": "Monthly environment consumption. Resets each calendar month.",
    "format": "double",
    "readOnly": true
    },
    "consumedThisYear": {
    "type": "number",
    "description": "Yearly environment consumption. Resets each year on license creation date anniversary.",
    "format": "double",
    "readOnly": true
    }
    },
    "description": "User session properties consumption information on environment level.",
    "readOnly": true
    },
    "SessionReplayRetention": {
    "type": "object",
    "properties": {
    "maxLimitInDays": {
    "type": "integer",
    "description": "Maximum retention limit [days]",
    "format": "int64"
    },
    "currentlyUsedInMillis": {
    "type": "integer",
    "description": "Current data age [milliseconds]",
    "format": "int64",
    "readOnly": true
    },
    "currentlyUsedInDays": {
    "type": "integer",
    "description": "Current data age [days]",
    "format": "int64",
    "readOnly": true
    }
    },
    "description": "Session replay retention settings on environment level. Can be set to any value from 1 to 35 days. If skipped when editing via PUT method then already set limit will remain."
    },
    "SessionReplayStorage": {
    "type": "object",
    "properties": {
    "retentionReductionPercentage": {
    "type": "string",
    "description": "Percentage of truncation for new data.",
    "format": "byte",
    "readOnly": true
    },
    "retentionReductionReason": {
    "type": "string",
    "description": "Reason of truncation.",
    "readOnly": true
    },
    "maxLimit": {
    "type": "integer",
    "description": "Maximum storage limit [bytes]",
    "format": "int64"
    },
    "currentlyUsed": {
    "type": "integer",
    "description": "Currently used storage [bytes]",
    "format": "int64",
    "readOnly": true
    }
    },
    "description": "Session replay storage usage and limit information on environment level. If skipped when editing via PUT method then already set limit will remain."
    },
    "SymbolFilesFromMobileApps": {
    "type": "object",
    "properties": {
    "maxLimit": {
    "type": "integer",
    "description": "Maximum storage limit [bytes]",
    "format": "int64"
    },
    "currentlyUsed": {
    "type": "integer",
    "description": "Currently used storage [bytes]",
    "format": "int64",
    "readOnly": true
    }
    },
    "description": "Symbol files from mobile apps storage usage and limit information on environment level. If skipped when editing via PUT method then already set limit will remain."
    },
    "SyntheticMonitoringRetention": {
    "type": "object",
    "properties": {
    "maxLimitInDays": {
    "type": "integer",
    "description": "Maximum retention limit [days]",
    "format": "int64"
    },
    "currentlyUsedInMillis": {
    "type": "integer",
    "description": "Current data age [milliseconds]",
    "format": "int64",
    "readOnly": true
    },
    "currentlyUsedInDays": {
    "type": "integer",
    "description": "Current data age [days]",
    "format": "int64",
    "readOnly": true
    }
    },
    "description": "Synthetic monitoring retention settings on environment level. Can be set to any value from 1 to 35 days. If skipped when editing via PUT method then already set limit will remain."
    },
    "SyntheticQuota": {
    "type": "object",
    "properties": {
    "consumedThisMonth": {
    "type": "number",
    "description": "Monthly environment consumption. Resets each calendar month.",
    "format": "double",
    "readOnly": true
    },
    "consumedThisYear": {
    "type": "number",
    "description": "Yearly environment consumption. Resets each year on license creation date anniversary.",
    "format": "double",
    "readOnly": true
    },
    "monthlyLimit": {
    "type": "integer",
    "description": "Monthly environment quota. Not set if unlimited. When updating via PUT method, skipping this field will set quota unlimited.",
    "format": "int64"
    },
    "annualLimit": {
    "type": "integer",
    "description": "Annual environment quota. Not set if unlimited. When updating via PUT method, skipping this field will set quota unlimited.",
    "format": "int64"
    }
    },
    "description": "Synthetic monitors consumption and quota information on environment level. Not set (and not editable) if neither Synthetic nor DEM units is enabled. If skipped when editing via PUT method then already set quotas will remain."
    },
    "TransactionStorage": {
    "type": "object",
    "properties": {
    "retentionReductionPercentage": {
    "type": "string",
    "description": "Percentage of truncation for new data.",
    "format": "byte",
    "readOnly": true
    },
    "retentionReductionReason": {
    "type": "string",
    "description": "Reason of truncation.",
    "readOnly": true
    },
    "maxLimit": {
    "type": "integer",
    "description": "Maximum storage limit [bytes]",
    "format": "int64"
    },
    "currentlyUsed": {
    "type": "integer",
    "description": "Currently used storage [bytes]",
    "format": "int64",
    "readOnly": true
    }
    },
    "description": "Transaction storage usage and limit information on environment level. If skipped when editing via PUT method then already set limit will remain."
    },
    "TransactionTrafficQuota": {
    "type": "object",
    "properties": {
    "maxLimit": {
    "type": "integer",
    "description": "Maximum traffic [units per minute]",
    "format": "int32"
    }
    },
    "description": "Maximum number of newly monitored entry point PurePaths captured per process/minute on environment level. Can be set to any value from 100 to 100000. If skipped when editing via PUT method then already set limit will remain."
    },
    "UserActionsPerMinute": {
    "type": "object",
    "properties": {
    "maxLimit": {
    "type": "integer",
    "description": "Maximum traffic [units per minute]",
    "format": "int32"
    }
    },
    "description": "Maximum number of user actions generated per minute on environment level. Can be set to any value from 1 to 2147483646 or left unlimited. If skipped when editing via PUT method then already set limit will remain."
    },
    "UserSessionsQuota": {
    "type": "object",
    "properties": {
    "consumedMobileSessionsThisYear": {
    "type": "number",
    "description": "Yearly Mobile user sessions environment consumption. Resets each year on license creation date anniversary.",
    "format": "double",
    "readOnly": true
    },
    "consumedMobileSessionsThisMonth": {
    "type": "number",
    "description": "Monthly Mobile user sessions environment consumption. Resets each calendar month.",
    "format": "double",
    "readOnly": true
    },
    "consumedUserSessionsWithWebSessionReplayThisMonth": {
    "type": "number",
    "description": "Monthly Web user sessions with replay environment consumption. Resets each calendar month.",
    "format": "double",
    "readOnly": true
    },
    "totalAnnualLimit": {
    "type": "integer",
    "description": "Annual total User sessions environment quota. Not set if unlimited. When updating via PUT method, skipping this field will set quota unlimited.",
    "format": "int64"
    },
    "totalMonthlyLimit": {
    "type": "integer",
    "description": "Monthly total User sessions environment quota. Not set if unlimited. When updating via PUT method, skipping this field will set quota unlimited.",
    "format": "int64"
    },
    "totalConsumedThisMonth": {
    "type": "number",
    "description": "Monthly total User sessions environment consumption. Resets each calendar month.",
    "format": "double",
    "readOnly": true
    },
    "totalConsumedThisYear": {
    "type": "number",
    "description": "Yearly total User sessions environment consumption. Resets each year on license creation date anniversary.",
    "format": "double",
    "readOnly": true
    },
    "consumedUserSessionsWithWebSessionReplayThisYear": {
    "type": "number",
    "description": "Yearly Web user sessions with replay environment consumption. Resets each year on license creation date anniversary.",
    "format": "double",
    "readOnly": true
    },
    "consumedUserSessionsWithMobileSessionReplayThisMonth": {
    "type": "number",
    "description": "Monthly Mobile user sessions with replay environment consumption. Resets each calendar month.",
    "format": "double",
    "readOnly": true
    },
    "consumedUserSessionsWithMobileSessionReplayThisYear": {
    "type": "number",
    "description": "Yearly Mobile user sessions with replay environment consumption. Resets each year on license creation date anniversary.",
    "format": "double",
    "readOnly": true
    }
    },
    "description": "User sessions consumption and quota information on environment level. If skipped when editing via PUT method then already set quotas will remain."
    },
    "EnvironmentShortRepresentation": {
    "required": [
    "id"
    ],
    "type": "object",
    "properties": {
    "id": {
    "type": "string",
    "description": "The ID of the Dynatrace entity."
    },
    "name": {
    "type": "string",
    "description": "The name of the Dynatrace entity.",
    "readOnly": true
    },
    "description": {
    "type": "string",
    "description": "A short description of the Dynatrace entity.",
    "readOnly": true
    },
    "tokenManagementToken": {
    "type": "string",
    "description": "A token with the 'Token management' permission. Can be used to within the newly created environment to create other tokens for configuring this environment. This value is only set if an environment was created with the query parameter 'createToken=true'.",
    "readOnly": true
    }
    },
    "description": "The short representation of an environment."
    },
    "Token": {
    "required": [
    "token"
    ],
    "type": "object",
    "properties": {
    "token": {
    "type": "string",
    "description": "Dynatrace API authentication token."
    }
    },
    "example": {
    "token": "abcdefjhij1234567890"
    }
    },
    "ConstraintViolation": {
    "type": "object",
    "properties": {
    "parameterLocation": {
    "type": "string",
    "enum": [
    "PATH",
    "PAYLOAD_BODY",
    "QUERY"
    ]
    },
    "location": {
    "type": "string"
    },
    "message": {
    "type": "string"
    },
    "path": {
    "type": "string"
    }
    },
    "description": "A list of constraint violations"
    },
    "Error": {
    "type": "object",
    "properties": {
    "constraintViolations": {
    "type": "array",
    "description": "A list of constraint violations",
    "items": {
    "$ref": "#/components/schemas/ConstraintViolation"
    }
    },
    "message": {
    "type": "string",
    "description": "The error message"
    },
    "code": {
    "type": "integer",
    "description": "The HTTP status code",
    "format": "int32"
    }
    }
    },
    "ErrorEnvelope": {
    "type": "object",
    "properties": {
    "error": {
    "$ref": "#/components/schemas/Error"
    }
    }
    },
    "CreateEnvironmentTokenManagementToken": {
    "required": [
    "name"
    ],
    "type": "object",
    "properties": {
    "name": {
    "type": "string",
    "description": "The name of the token."
    },
    "expiresIn": {
    "$ref": "#/components/schemas/Duration"
    }
    },
    "example": {
    "name": "Token Management",
    "expiresIn": {
    "value": 3600,
    "unit": "SECONDS"
    }
    }
    },
    "Duration": {
    "required": [
    "value"
    ],
    "type": "object",
    "properties": {
    "value": {
    "type": "integer",
    "description": "The amount of time.",
    "format": "int64"
    },
    "unit": {
    "type": "string",
    "description": "The unit of time. \n\n If not set, millisecond is used.",
    "enum": [
    "DAYS",
    "HOURS",
    "MILLIS",
    "MINUTES",
    "SECONDS"
    ]
    }
    },
    "description": "Defines a period of time."
    },
    "EnvironmentList": {
    "required": [
    "environments",
    "totalCount"
    ],
    "type": "object",
    "properties": {
    "totalCount": {
    "type": "integer",
    "description": "The total number of entries in the result.",
    "format": "int64"
    },
    "pageSize": {
    "type": "integer",
    "description": "The number of entries per page.",
    "format": "int32"
    },
    "nextPageKey": {
    "type": "string",
    "description": "The cursor for the next page of results. Has the value of `null` on the last page. \n\nUse it in the **nextPageKey** query parameter to obtain subsequent pages of the result.",
    "example": "AQAAABQBAAAABQ=="
    },
    "environments": {
    "type": "array",
    "description": "The list of environments.",
    "items": {
    "$ref": "#/components/schemas/Environment"
    }
    }
    },
    "description": "A list of environments."
    },
    "AccessRequestStateData": {
    "type": "object",
    "properties": {
    "state": {
    "type": "string",
    "description": "Access request state",
    "enum": [
    "ACCEPTED",
    "EXPIRED",
    "PENDING",
    "REJECTED"
    ]
    }
    },
    "description": "Access request data - format used to change a state of a request"
    },
    "AccessRequestData": {
    "type": "object",
    "properties": {
    "requestId": {
    "type": "string",
    "description": "Request id"
    },
    "userId": {
    "type": "string",
    "description": "User id"
    },
    "reason": {
    "type": "string",
    "description": "Request reason description"
    },
    "requestedDays": {
    "type": "integer",
    "description": "For how many days access is requested",
    "format": "int32"
    },
    "role": {
    "type": "string",
    "description": "Requested role",
    "enum": [
    "devops-admin",
    "devops-user",
    "devops-viewer"
    ]
    },
    "createdTimestamp": {
    "type": "integer",
    "description": "Access request created at (timestamp)",
    "format": "int64"
    },
    "expirationTimestamp": {
    "type": "integer",
    "description": "Access expires at (timestamp)",
    "format": "int64"
    },
    "state": {
    "type": "string",
    "description": "Access request state",
    "enum": [
    "ACCEPTED",
    "EXPIRED",
    "PENDING",
    "REJECTED"
    ]
    },
    "stateModifiedByUser": {
    "type": "string",
    "description": "Access request state was modified by user"
    }
    },
    "description": "Access Request data"
    },
    "CreateAccessRequestDto": {
    "type": "object",
    "properties": {
    "userId": {
    "type": "string",
    "description": "User id"
    },
    "reason": {
    "type": "string",
    "description": "Request reason description"
    },
    "requestedDays": {
    "type": "integer",
    "description": "For how many days access is requested",
    "format": "int32"
    },
    "role": {
    "type": "string",
    "description": "Requested role",
    "enum": [
    "devops-admin",
    "devops-user",
    "devops-viewer"
    ]
    }
    },
    "description": "Access request data - format used to create a request"
    },
    "AutomaticLogoutConfiguration": {
    "required": [
    "logoutInactiveUsersEnabled",
    "userInactivityTimeout"
    ],
    "type": "object",
    "properties": {
    "logoutInactiveUsersEnabled": {
    "type": "boolean",
    "description": "True if automatic logout is enabled"
    },
    "userInactivityTimeout": {
    "minimum": 1,
    "type": "integer",
    "description": "User inactivity timeout",
    "format": "int32"
    }
    },
    "description": "Configuration of automatic logout.",
    "example": {
    "logoutInactiveUsersEnabled": true,
    "userInactivityTimeout": 900
    }
    },
    "ConcurrentSessionPolicy": {
    "required": [
    "adminLimit",
    "userLimit"
    ],
    "type": "object",
    "properties": {
    "userLimit": {
    "type": "integer",
    "description": "Session limit for regular users (0 = no limit)",
    "format": "int32"
    },
    "adminLimit": {
    "type": "integer",
    "description": "Session limit for admin users (0 = no limit)",
    "format": "int32"
    }
    },
    "description": "The configuration of the concurrent sessions policy. Set '0' to disable session limitation."
    },
    "UserSessionsConfig": {
    "required": [
    "automaticLogoutDto",
    "concurrentSessionPolicyDto"
    ],
    "type": "object",
    "properties": {
    "concurrentSessionPolicyDto": {
    "$ref": "#/components/schemas/ConcurrentSessionPolicy"
    },
    "automaticLogoutDto": {
    "$ref": "#/components/schemas/AutomaticLogoutConfiguration"
    }
    },
    "description": "The configuration of user sessions - concurrent sessions policy and automatic logout."
    },
    "UserSession": {
    "required": [
    "creationTime",
    "loginType",
    "nodeId",
    "sessionId",
    "tenantUuid",
    "userId"
    ],
    "type": "object",
    "properties": {
    "userId": {
    "type": "string",
    "description": "User id"
    },
    "nodeId": {
    "type": "integer",
    "description": "Node on which user session exists",
    "format": "int32"
    },
    "sessionId": {
    "type": "string",
    "description": "User session id"
    },
    "creationTime": {
    "type": "integer",
    "description": "User session creation timestamp",
    "format": "int64"
    },
    "lastAccessedTimestamp": {
    "type": "integer",
    "description": "Timestamp when session was recently accessed",
    "format": "int64"
    },
    "tenantUuid": {
    "type": "string",
    "description": "UUID of tenant to which user has logged in (or cluster UUID if user has logged in to CMC)"
    },
    "loginType": {
    "type": "string",
    "description": "The way user has logged in",
    "enum": [
    "LOCAL",
    "LDAP",
    "SSO_MANAGED",
    "DEVOPSTOKEN"
    ]
    },
    "device": {
    "type": "string",
    "description": "Device on which user has logged in"
    },
    "ip": {
    "type": "string",
    "description": "IP from which has logged in"
    }
    },
    "description": "Managed user session instance"
    },
    "ActiveGateAutoUpdateConfig": {
    "required": [
    "setting"
    ],
    "type": "object",
    "properties": {
    "setting": {
    "type": "string",
    "description": "The state of the ActiveGate auto-update: enabled, disabled, or inherited. \n\nIf set to `INHERITED`, the setting is inherited from the global configuration set on the environment or Managed cluster level.",
    "example": "INHERITED",
    "enum": [
    "DISABLED",
    "ENABLED",
    "INHERITED"
    ]
    },
    "effectiveSetting": {
    "type": "string",
    "description": "The actual state of the ActiveGate auto-update. \n\nApplicable only if the **setting** parameter is set to `INHERITED`. In that case, the value is taken from the parent setting. Otherwise, it's just a duplicate of the **setting** value.",
    "readOnly": true,
    "example": "ENABLED",
    "enum": [
    "ENABLED",
    "DISABLED"
    ]
    }
    },
    "description": "Configuration of the ActiveGate auto-updates.",
    "readOnly": true
    },
    "ActiveGateGlobalAutoUpdateConfig": {
    "required": [
    "globalSetting"
    ],
    "type": "object",
    "properties": {
    "globalSetting": {
    "type": "string",
    "description": "The state of auto-updates for all ActiveGates connected to the environment or Managed cluster. \n\nThis setting is inherited by all ActiveGates that have the `INHERITED` setting.",
    "enum": [
    "ENABLED",
    "DISABLED"
    ]
    },
    "metadata": {
    "$ref": "#/components/schemas/ConfigurationMetadata"
    }
    },
    "description": "Global configuration of ActiveGates auto-update."
    },
    "ConfigurationMetadata": {
    "type": "object",
    "properties": {
    "configurationVersions": {
    "type": "array",
    "description": "A sorted list of the version numbers of the configuration.",
    "example": [
    4,
    2
    ],
    "items": {
    "type": "integer",
    "format": "int64"
    }
    },
    "currentConfigurationVersions": {
    "type": "array",
    "description": "A sorted list of version numbers of the configuration.",
    "example": [
    "1.0.4",
    "1.23"
    ],
    "items": {
    "type": "string"
    }
    },
    "clusterVersion": {
    "type": "string",
    "description": "Dynatrace version.",
    "example": "1.192.1"
    }
    },
    "description": "Metadata useful for debugging",
    "readOnly": true
    },
    "UpdateJob": {
    "required": [
    "targetVersion"
    ],
    "type": "object",
    "properties": {
    "environments": {
    "type": "array",
    "description": "A list of environments (specified by IDs) the ActiveGate can connect to.",
    "readOnly": true,
    "items": {
    "type": "string"
    }
    },
    "jobState": {
    "type": "string",
    "description": "The status of the update job.",
    "readOnly": true,
    "example": "SUCCEED",
    "enum": [
    "FAILED",
    "IN_PROGRESS",
    "PENDING",
    "ROLLBACK",
    "SCHEDULED",
    "SKIPPED",
    "SUCCEED"
    ]
    },
    "updateMethod": {
    "type": "string",
    "description": "The method of updating the ActiveGate or its component.",
    "readOnly": true,
    "example": "AUTOMATIC",
    "enum": [
    "AUTOMATIC",
    "MANUAL_INSTALLATION",
    "ON_DEMAND"
    ]
    },
    "updateType": {
    "type": "string",
    "description": "The component to be updated.",
    "readOnly": true,
    "example": "ACTIVE_GATE",
    "enum": [
    "ACTIVE_GATE",
    "REMOTE_PLUGIN_AGENT",
    "SYNTHETIC",
    "Z_REMOTE"
    ]
    },
    "agType": {
    "type": "string",
    "description": "The type of the ActiveGate.",
    "readOnly": true,
    "example": "ENVIRONMENT",
    "enum": [
    "CLUSTER",
    "ENVIRONMENT",
    "ENVIRONMENT_MULTI"
    ]
    },
    "startVersion": {
    "type": "string",
    "description": "The initial version of the ActiveGate.",
    "readOnly": true,
    "example": "1.185.0.20200201-120000"
    },
    "cancelable": {
    "type": "boolean",
    "description": "The job can (`true`) or can't (`false`) be cancelled at the moment.",
    "readOnly": true,
    "example": false
    },
    "jobId": {
    "type": "string",
    "description": "The ID of the update job.",
    "readOnly": true,
    "example": "-3524498778810258605"
    },
    "timestamp": {
    "type": "integer",
    "description": "The timestamp of the update job completion. \n\n The `null` value means the job is still running.",
    "format": "int64",
    "readOnly": true,
    "example": 1582031917814
    },
    "duration": {
    "type": "integer",
    "description": "The duration of the update, in milliseconds.",
    "format": "int64",
    "readOnly": true,
    "example": 3608000
    },
    "targetVersion": {
    "type": "string",
    "description": "The target version of the update. \n\nSpecify the version in the `<major>.<minor>.<revision>.<timestamp>` format. \n\nTo update to the latest available version, use the `latest` value.",
    "example": "1.190.0.20200301-130000"
    },
    "error": {
    "type": "string",
    "description": "The information about update error.",
    "readOnly": true
    }
    },
    "description": "Configuration of the ActiveGate update job."
    },
    "UpdateJobList": {
    "type": "object",
    "properties": {
    "agId": {
    "type": "string",
    "description": "The ID of the ActiveGate.",
    "readOnly": true,
    "example": "0x3efdd092"
    },
    "updateJobs": {
    "type": "array",
    "description": "A list of update jobs of the ActiveGate.",
    "readOnly": true,
    "items": {
    "$ref": "#/components/schemas/UpdateJob"
    }
    }
    },
    "description": "A list of update jobs of the ActiveGate."
    },
    "UpdateJobsAll": {
    "type": "object",
    "properties": {
    "allUpdateJobs": {
    "type": "array",
    "description": "A list of ActiveGates with update jobs.",
    "readOnly": true,
    "items": {
    "$ref": "#/components/schemas/UpdateJobList"
    }
    }
    },
    "description": "A list of ActiveGates with update jobs."
    },
    "ActiveGate": {
    "type": "object",
    "properties": {
    "id": {
    "type": "string",
    "description": "The ID of the ActiveGate.",
    "readOnly": true,
    "example": "0x3efdd091"
    },
    "networkAddresses": {
    "type": "array",
    "description": "A list of network addresses of the ActiveGate.",
    "readOnly": true,
    "items": {
    "type": "string"
    }
    },
    "loadBalancerAddresses": {
    "type": "array",
    "description": "A list of Load Balancer addresses of the ActiveGate.",
    "readOnly": true,
    "items": {
    "type": "string"
    }
    },
    "osType": {
    "type": "string",
    "description": "The OS type that the ActiveGate is running on.",
    "readOnly": true,
    "example": "WINDOWS",
    "enum": [
    "LINUX",
    "WINDOWS"
    ]
    },
    "autoUpdateStatus": {
    "type": "string",
    "description": "The current status of auto-updates of the ActiveGate.",
    "readOnly": true,
    "example": "OUTDATED",
    "enum": [
    "INCOMPATIBLE",
    "OUTDATED",
    "SCHEDULED",
    "SUPPRESSED",
    "UNKNOWN",
    "UP2DATE",
    "UPDATE_IN_PROGRESS",
    "UPDATE_PENDING",
    "UPDATE_PROBLEM"
    ]
    },
    "offlineSince": {
    "type": "integer",
    "description": "The timestamp since when the ActiveGate is offline. \n\n The `null` value means the ActiveGate is online.",
    "format": "int64",
    "readOnly": true,
    "example": 1582031917814
    },
    "version": {
    "type": "string",
    "description": "The current version of the ActiveGate in the `<major>.<minor>.<revision>.<timestamp>` format.",
    "readOnly": true,
    "example": "1.185.0.20200201-120000"
    },
    "type": {
    "type": "string",
    "description": "The type of the ActiveGate.",
    "readOnly": true,
    "example": "ENVIRONMENT",
    "enum": [
    "CLUSTER",
    "ENVIRONMENT",
    "ENVIRONMENT_MULTI"
    ]
    },
    "hostname": {
    "type": "string",
    "description": "The name of the host the ActiveGate is running on.",
    "readOnly": true,
    "example": "exampleHostname"
    },
    "mainEnvironment": {
    "type": "string",
    "description": "The ID of the main environment for a multi-environment ActiveGate.",
    "readOnly": true,
    "example": "d1bf4a7e-666b-43af-9f45-718g98372e2f"
    },
    "environments": {
    "type": "array",
    "description": "A list of environments (specified by IDs) the ActiveGate can connect to.",
    "readOnly": true,
    "items": {
    "type": "string"
    }
    },
    "autoUpdateSettings": {
    "$ref": "#/components/schemas/ActiveGateAutoUpdateConfig"
    },
    "networkZone": {
    "type": "string",
    "description": "The network zone of the ActiveGate.",
    "readOnly": true,
    "example": "exampleNetworkZone"
    },
    "group": {
    "type": "string",
    "description": "The group of the ActiveGate.",
    "readOnly": true,
    "example": "default"
    },
    "modules": {
    "type": "array",
    "description": "A list of modules of the ActiveGate.",
    "readOnly": true,
    "items": {
    "$ref": "#/components/schemas/ActiveGateModule"
    }
    },
    "containerized": {
    "type": "boolean",
    "description": "ActiveGate is deployed in container (`true`) or not (`false`).",
    "readOnly": true
    }
    },
    "description": "Parameters of the ActiveGate."
    },
    "ActiveGateList": {
    "type": "object",
    "properties": {
    "activeGates": {
    "type": "array",
    "description": "A list of ActiveGates.",
    "readOnly": true,
    "items": {
    "$ref": "#/components/schemas/ActiveGate"
    }
    }
    },
    "description": "A list of ActiveGates."
    },
    "ActiveGateModule": {
    "type": "object",
    "properties": {
    "misconfigured": {
    "type": "boolean",
    "description": "The module is misconfigured (`true`) or not (`false`).",
    "readOnly": true
    },
    "enabled": {
    "type": "boolean",
    "description": "The module is enabled (`true`) or disabled (`false`).",
    "readOnly": true
    },
    "version": {
    "type": "string",
    "description": "The version of the ActiveGate module.",
    "readOnly": true
    },
    "type": {
    "type": "string",
    "description": "The type of ActiveGate module.",
    "readOnly": true,
    "example": "KUBERNETES",
    "enum": [
    "AWS",
    "AZURE",
    "BEACON_FORWARDER",
    "CLOUD_FOUNDRY",
    "DB_INSIGHT",
    "EXTENSIONS_V1",
    "EXTENSIONS_V2",
    "KUBERNETES",
    "LOGS",
    "MEMORY_DUMPS",
    "METRIC_API",
    "ONE_AGENT_ROUTING",
    "OTLP_INGEST",
    "REST_API",
    "SYNTHETIC",
    "VMWARE",
    "Z_OS"
    ]
    },
    "attributes": {
    "type": "object",
    "additionalProperties": {
    "type": "string",
    "description": "The attributes of the ActiveGate module.",
    "readOnly": true
    },
    "description": "The attributes of the ActiveGate module.",
    "readOnly": true
    }
    },
    "description": "Information about ActiveGate module"
    },
    "ActiveGateInstallerVersions": {
    "type": "object",
    "properties": {
    "availableVersions": {
    "type": "array",
    "description": "Available versions.",
    "items": {
    "type": "string"
    }
    }
    },
    "description": "A list of available versions of ActiveGate installer."
    },
    "NetworkZone": {
    "type": "object",
    "properties": {
    "alternativeZones": {
    "uniqueItems": true,
    "type": "array",
    "description": "A list of alternative network zones.",
    "items": {
    "type": "string"
    }
    },
    "numOfOneAgentsUsing": {
    "type": "integer",
    "description": "The number of OneAgents that are using ActiveGates in the network zone.",
    "format": "int32",
    "readOnly": true
    },
    "numOfConfiguredOneAgents": {
    "type": "integer",
    "description": "The number of OneAgents that are configured to use the network zone as primary.",
    "format": "int32",
    "readOnly": true
    },
    "numOfOneAgentsFromOtherZones": {
    "type": "integer",
    "description": "The number of OneAgents from other network zones that are using ActiveGates in the network zone. \n\n This is a fraction of **numOfOneAgentsUsing**. \n\nOne possible reason for switching to another zone is that a firewall is preventing a OneAgent from connecting to any ActiveGate in the preferred network zone.\n\n",
    "format": "int32",
    "readOnly": true
    },
    "numOfConfiguredActiveGates": {
    "type": "integer",
    "description": "The number of ActiveGates in the network zone.",
    "format": "int32",
    "readOnly": true
    },
    "id": {
    "type": "string",
    "description": "The ID of the network zone",
    "readOnly": true
    },
    "description": {
    "type": "string",
    "description": "A short description of the network zone"
    }
    },
    "description": "Configuration of a network zone."
    },
    "NetworkZoneList": {
    "required": [
    "networkZones"
    ],
    "type": "object",
    "properties": {
    "networkZones": {
    "type": "array",
    "description": "A list of network zones.",
    "items": {
    "$ref": "#/components/schemas/NetworkZone"
    }
    }
    },
    "description": "A list of network zones."
    },
    "EntityShortRepresentation": {
    "required": [
    "id"
    ],
    "type": "object",
    "properties": {
    "id": {
    "type": "string",
    "description": "The ID of the Dynatrace entity."
    },
    "name": {
    "type": "string",
    "description": "The name of the Dynatrace entity.",
    "readOnly": true
    },
    "description": {
    "type": "string",
    "description": "A short description of the Dynatrace entity.",
    "readOnly": true
    }
    },
    "description": "The short representation of a Dynatrace entity.",
    "example": {
    "id": "6a98d7bc-abb9-44f8-ae6a-73e68e71812a",
    "name": "Dynatrace entity",
    "description": "Dynatrace entity for the REST API example"
    }
    },
    "UpdateToken": {
    "type": "object",
    "properties": {
    "revoked": {
    "type": "boolean",
    "description": "The token is revoked (`true`) or active (`false`)."
    },
    "name": {
    "type": "string",
    "description": "The name of the token."
    },
    "scopes": {
    "uniqueItems": true,
    "type": "array",
    "description": "The list of permissions assigned to the token. \n\nApart from the new permissions, you need to submit the existing permissions you want to keep, too. Any existing permission, missing in the payload, is revoked.\n\n* `DiagnosticExport`: DiagnosticExport. \n* `ControlManagement`: ControlManagement. \n* `UnattendedInstall`: UnattendedInstall. \n* `ServiceProviderAPI`: Service Provider API. \n* `ExternalSyntheticIntegration`: Create and read synthetic monitors, locations, and nodes. \n* `ClusterTokenManagement`: Cluster token management. \n* `ReadSyntheticData`: Read synthetic monitors, locations, and nodes. \n* `Nodekeeper`: Nodekeeper access for node management. \n* `EnvironmentTokenManagement`: \"Token Management\" Token creation for existing environments. \n* `settings.read`: Read settings. \n* `settings.write`: Write settings. \n* `apiTokens.read`: Read API tokens. \n* `apiTokens.write`: Write API tokens. \n",
    "items": {
    "type": "string",
    "enum": [
    "DiagnosticExport",
    "ControlManagement",
    "UnattendedInstall",
    "ServiceProviderAPI",
    "ExternalSyntheticIntegration",
    "ClusterTokenManagement",
    "ReadSyntheticData",
    "Nodekeeper",
    "EnvironmentTokenManagement",
    "settings.read",
    "settings.write",
    "apiTokens.read",
    "apiTokens.write"
    ]
    }
    }
    }
    },
    "TokenMetadata": {
    "type": "object",
    "properties": {
    "id": {
    "type": "string",
    "description": "The ID of the token.",
    "readOnly": true
    },
    "name": {
    "type": "string",
    "description": "The name of the token."
    },
    "userId": {
    "type": "string",
    "description": "The owner of the token.",
    "readOnly": true
    },
    "revoked": {
    "type": "boolean",
    "description": "Revocation status of the token. Revoked tokens are disabled."
    },
    "created": {
    "type": "integer",
    "description": "The creation time as a unix timestamp in milliseconds.",
    "format": "int64",
    "readOnly": true
    },
    "expires": {
    "type": "integer",
    "description": "The expiration time as a unix timestamp in milliseconds.",
    "format": "int64"
    },
    "lastUse": {
    "type": "integer",
    "description": "The unix timestamp in milliseconds when the token was last used.",
    "format": "int64",
    "readOnly": true
    },
    "scopes": {
    "type": "array",
    "description": "A list of scopes assigned to the token.",
    "items": {
    "type": "string",
    "enum": [
    "ClusterTokenManagement",
    "ControlManagement",
    "DiagnosticExport",
    "EnvironmentTokenManagement",
    "ExternalSyntheticIntegration",
    "Nodekeeper",
    "ReadSyntheticData",
    "ServiceProviderAPI",
    "UnattendedInstall",
    "apiTokens.read",
    "apiTokens.write",
    "settings.read",
    "settings.write"
    ]
    }
    },
    "personalAccessToken": {
    "type": "boolean",
    "description": "The token is a [personal access token](https://dt-url.net/wm03sop) (`true`) or an API token (`false`).",
    "readOnly": true
    }
    },
    "description": "Metadata of a token.",
    "example": {
    "id": "acbed0c4-4ef1-4303-991f-102510a69322",
    "name": "myToken",
    "userId": "john.smith",
    "revoked": true,
    "created": 1554076800000,
    "expires": 1585976400000,
    "lastUse": 1554354000000,
    "personalAccessToken": true,
    "scopes": [
    "DataExport",
    "ReadConfig",
    "WriteConfig"
    ]
    }
    },
    "StubList": {
    "required": [
    "values"
    ],
    "type": "object",
    "properties": {
    "values": {
    "type": "array",
    "description": "An ordered list of short representations of Dynatrace entities.",
    "items": {
    "$ref": "#/components/schemas/EntityShortRepresentation"
    }
    }
    },
    "description": "An ordered list of short representations of Dynatrace entities.",
    "example": {
    "values": [
    {
    "id": "6a98d7bc-abb9-44f8-ae6a-73e68e71812a",
    "name": "Dynatrace entity 1",
    "description": "Dynatrace entity 1 for the REST API example"
    },
    {
    "id": "ee70f7d3-9a4e-4f5f-94d2-c9d6156f1618",
    "name": "Dynatrace entity 2"
    },
    {
    "id": "8cdabe77-9e1a-4be8-b3df-269dd6fa9d7f"
    }
    ]
    }
    },
    "CreateToken": {
    "required": [
    "name",
    "scopes"
    ],
    "type": "object",
    "properties": {
    "name": {
    "type": "string",
    "description": "The name of the token."
    },
    "expiresIn": {
    "$ref": "#/components/schemas/Duration"
    },
    "scopes": {
    "minItems": 1,
    "uniqueItems": true,
    "type": "array",
    "description": "The list of scopes to be assigned to the token.\n\n* `DiagnosticExport`: DiagnosticExport. \n* `ControlManagement`: ControlManagement. \n* `UnattendedInstall`: UnattendedInstall. \n* `ServiceProviderAPI`: Service Provider API. \n* `ExternalSyntheticIntegration`: Create and read synthetic monitors, locations, and nodes. \n* `ClusterTokenManagement`: Cluster token management. \n* `ReadSyntheticData`: Read synthetic monitors, locations, and nodes. \n* `Nodekeeper`: Nodekeeper access for node management. \n* `EnvironmentTokenManagement`: \"Token Management\" Token creation for existing environments. \n* `settings.read`: Read settings. \n* `settings.write`: Write settings. \n* `apiTokens.read`: Read API tokens. \n* `apiTokens.write`: Write API tokens. \n",
    "items": {
    "type": "string",
    "enum": [
    "DiagnosticExport",
    "ControlManagement",
    "UnattendedInstall",
    "ServiceProviderAPI",
    "ExternalSyntheticIntegration",
    "ClusterTokenManagement",
    "ReadSyntheticData",
    "Nodekeeper",
    "EnvironmentTokenManagement",
    "settings.read",
    "settings.write",
    "apiTokens.read",
    "apiTokens.write"
    ]
    }
    }
    }
    },
    "ConditionConfiguration": {
    "type": "object",
    "properties": {
    "name": {
    "type": "string"
    },
    "description": {
    "type": "string"
    },
    "operators": {
    "type": "array",
    "items": {
    "type": "string"
    }
    }
    }
    },
    "DynamicConditionConfiguration": {
    "type": "object",
    "properties": {
    "prefix": {
    "type": "string"
    },
    "description": {
    "type": "string"
    },
    "operators": {
    "type": "array",
    "items": {
    "type": "string"
    }
    }
    }
    },
    "PermissionConfiguration": {
    "type": "object",
    "properties": {
    "name": {
    "type": "string"
    },
    "description": {
    "type": "string"
    },
    "conditions": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/ConditionConfiguration"
    }
    },
    "dynamicConditionPrefixes": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/DynamicConditionConfiguration"
    }
    }
    }
    },
    "ServiceConfiguration": {
    "type": "object",
    "properties": {
    "name": {
    "type": "string"
    },
    "description": {
    "type": "string"
    },
    "permissions": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/PermissionConfiguration"
    }
    },
    "status": {
    "type": "string",
    "enum": [
    "GENERAL_AVAILABILITY",
    "IN_DEVELOPMENT"
    ]
    }
    }
    },
    "StatementConfiguration": {
    "type": "object",
    "properties": {
    "services": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/ServiceConfiguration"
    }
    }
    }
    },
    "PolicyUuids": {
    "type": "object",
    "properties": {
    "policyUuids": {
    "uniqueItems": true,
    "type": "array",
    "items": {
    "type": "string",
    "format": "uuid"
    }
    }
    }
    },
    "ErrorMessage": {
    "type": "object",
    "properties": {
    "error": {
    "$ref": "#/components/schemas/Error"
    }
    }
    },
    "LevelPolicyBinding": {
    "required": [
    "groups",
    "policyUuid"
    ],
    "type": "object",
    "properties": {
    "policyUuid": {
    "type": "string",
    "format": "uuid"
    },
    "groups": {
    "maxItems": 200,
    "minItems": 1,
    "uniqueItems": true,
    "type": "array",
    "items": {
    "type": "string"
    }
    }
    }
    },
    "LevelPolicyBindingsList": {
    "required": [
    "policyBindings"
    ],
    "type": "object",
    "properties": {
    "levelType": {
    "type": "string"
    },
    "levelId": {
    "type": "string"
    },
    "policyBindings": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/LevelPolicyBinding"
    }
    }
    }
    },
    "AppendLevelPolicyBindingsRequest": {
    "required": [
    "groups"
    ],
    "type": "object",
    "properties": {
    "groups": {
    "maxItems": 200,
    "minItems": 1,
    "uniqueItems": true,
    "type": "array",
    "items": {
    "type": "string"
    }
    }
    }
    },
    "CreateOrUpdateGroupBindings": {
    "required": [
    "policyUuids"
    ],
    "type": "object",
    "properties": {
    "policyUuids": {
    "uniqueItems": true,
    "type": "array",
    "items": {
    "type": "string",
    "format": "uuid"
    }
    }
    }
    },
    "CreateLevelPolicyBindingsRequest": {
    "required": [
    "policyBindings"
    ],
    "type": "object",
    "properties": {
    "policyBindings": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/LevelPolicyBinding"
    }
    }
    }
    },
    "PolicyOverview": {
    "type": "object",
    "properties": {
    "uuid": {
    "type": "string",
    "format": "uuid"
    },
    "name": {
    "type": "string"
    },
    "description": {
    "type": "string"
    },
    "levelType": {
    "type": "string"
    },
    "levelId": {
    "type": "string"
    }
    }
    },
    "PolicyOverviewList": {
    "type": "object",
    "properties": {
    "policyOverviewList": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/PolicyOverview"
    }
    }
    }
    },
    "LevelPoliciesBasicDataList": {
    "type": "object",
    "properties": {
    "policies": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/PolicyBasicData"
    }
    }
    }
    },
    "PolicyBasicData": {
    "type": "object",
    "properties": {
    "uuid": {
    "type": "string",
    "format": "uuid"
    },
    "name": {
    "type": "string"
    },
    "description": {
    "type": "string"
    }
    }
    },
    "Condition": {
    "required": [
    "name",
    "operator",
    "values"
    ],
    "type": "object",
    "properties": {
    "name": {
    "maxLength": 2147483647,
    "minLength": 1,
    "type": "string"
    },
    "operator": {
    "type": "string",
    "enum": [
    "EQ",
    "IN",
    "NEQ",
    "NOT_IN",
    "NOT_STARTS_WITH",
    "STARTS_WITH"
    ]
    },
    "values": {
    "maxItems": 2147483647,
    "minItems": 1,
    "type": "array",
    "items": {
    "type": "string"
    }
    }
    }
    },
    "Policy": {
    "required": [
    "name",
    "statementQuery",
    "statements"
    ],
    "type": "object",
    "properties": {
    "uuid": {
    "type": "string",
    "format": "uuid"
    },
    "name": {
    "maxLength": 500,
    "minLength": 3,
    "type": "string"
    },
    "description": {
    "maxLength": 2000,
    "minLength": 0,
    "type": "string"
    },
    "tags": {
    "type": "array",
    "items": {
    "type": "string"
    }
    },
    "statementQuery": {
    "type": "string"
    },
    "statements": {
    "maxItems": 100,
    "minItems": 1,
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/Statement"
    }
    }
    }
    },
    "Statement": {
    "required": [
    "effect",
    "permissions"
    ],
    "type": "object",
    "properties": {
    "effect": {
    "type": "string",
    "enum": [
    "ALLOW",
    "DENY"
    ]
    },
    "permissions": {
    "maxItems": 2147483647,
    "minItems": 1,
    "type": "array",
    "items": {
    "type": "string"
    }
    },
    "conditions": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/Condition"
    }
    }
    }
    },
    "CreateOrUpdateLevelPolicyRequest": {
    "type": "object",
    "properties": {
    "name": {
    "type": "string"
    },
    "description": {
    "type": "string"
    },
    "tags": {
    "type": "array",
    "items": {
    "type": "string"
    }
    },
    "statementQuery": {
    "type": "string"
    }
    }
    },
    "ValidationWarnings": {
    "type": "object",
    "properties": {
    "warnings": {
    "type": "array",
    "items": {
    "type": "string"
    }
    }
    }
    },
    "Level": {
    "required": [
    "parentId",
    "parentType"
    ],
    "type": "object",
    "properties": {
    "type": {
    "maxLength": 100,
    "minLength": 0,
    "type": "string"
    },
    "id": {
    "maxLength": 36,
    "minLength": 0,
    "type": "string"
    },
    "parentType": {
    "maxLength": 100,
    "minLength": 1,
    "type": "string"
    },
    "parentId": {
    "maxLength": 36,
    "minLength": 1,
    "type": "string"
    },
    "modifiedAt": {
    "type": "string"
    }
    }
    },
    "LevelList": {
    "type": "object",
    "properties": {
    "levels": {
    "type": "array",
    "items": {
    "$ref": "#/components/schemas/Level"
    }
    }
    }
    },
    "ObjectsList": {
    "required": [
    "totalCount"
    ],
    "type": "object",
    "properties": {
    "items": {
    "type": "array",
    "description": "A list of settings objects.",
    "items": {
    "$ref": "#/components/schemas/SettingsObject"
    }
    },
    "nextPageKey": {
    "type": "string",
    "description": "The cursor for the next page of results. Has the value of `null` on the last page. \n\nUse it in the **nextPageKey** query parameter to obtain subsequent pages of the result.",
    "example": "AQAAABQBAAAABQ=="
    },
    "pageSize": {
    "type": "integer",
    "description": "The number of entries per page.",
    "format": "int32"
    },
    "totalCount": {
    "type": "integer",
    "description": "The total number of entries in the result.",
    "format": "int64"
    }
    },
    "description": "A list of settings objects."
    },
    "SettingsObject": {
    "type": "object",
    "properties": {
    "modified": {
    "type": "integer",
    "description": "The timestamp of the last modification.",
    "format": "int64"
    },
    "schemaVersion": {
    "type": "string",
    "description": "The version of the schema on which the object is based.",
    "example": "1.0.0"
    },
    "updateToken": {
    "type": "string",
    "description": "The update token of the object. You can use it to detect simultaneous modifications by different users. \n\nIt is generated upon retrieval (GET requests). If set on update (PUT request) or deletion, the update/deletion will be allowed only if there wasn't any change between the retrieval and the update. \n\nIf omitted on update/deletion, the operation overrides the current value or deletes it without any checks.",
    "example": "Y2ktaGdyb3VwLTEyMythZjhjOThlOS0wN2I0LTMyMGEtOTQzNi02NTEyMmVlNWY4NGQ="
    },
    "author": {
    "type": "string",
    "description": "The user (identified by a user ID or a public token ID) who performed that most recent modification.",
    "example": "john.doe@example.com"
    },
    "schemaId": {
    "type": "string",
    "description": "The schema on which the object is based.",
    "example": "builtin:anomaly.infrastructure"
    },
    "value": {
    "$ref": "#/components/schemas/SettingsValue"
    },
    "scope": {
    "type": "string",
    "description": "The scope that the object targets.",
    "example": "HOST-D3A3C5A146830A79"
    },
    "objectId": {
    "type": "string",
    "description": "The ID of the settings object.",
    "example": "Y2ktaGdyb3VwLTEyMythZjhjOThlOS0wN2I0LTMyMGEtOTQzNi02NTEyMmVlNWY4NGQ="
    },
    "summary": {
    "type": "string",
    "description": "A short summary of settings."
    },
    "created": {
    "type": "integer",
    "description": "The timestamp of the creation.",
    "format": "int64"
    }
    },
    "description": "A settings object."
    },
    "SettingsValue": {
    "type": "object",
    "description": "The value of the setting. \n\n It defines the actual values of settings' parameters. \n\nThe actual content depends on the object's schema.",
    "example": {
    "autoMonitoring": true
    }
    },
    "SettingsObjectResponse": {
    "type": "object",
    "properties": {
    "invalidValue": {
    "$ref": "#/components/schemas/SettingsValue"
    },
    "objectId": {
    "type": "string",
    "description": "For a successful request, the ID of the created or modified settings object.",
    "example": "Y2ktaGdyb3VwLTEyMythZjhjOThlOS0wN2I0LTMyMGEtOTQzNi02NTEyMmVlNWY4NGQ="
    },
    "code": {
    "type": "integer",
    "description": "The HTTP status code for the object.",
    "format": "int32"
    },
    "error": {
    "$ref": "#/components/schemas/Error"
    }
    },
    "description": "The response to a creation- or update-request."
    },
    "SettingsObjectCreate": {
    "required": [
    "schemaId",
    "scope",
    "value"
    ],
    "type": "object",
    "properties": {
    "schemaVersion": {
    "type": "string",
    "description": "The version of the schema on which the object is based.",
    "example": "1.0.0"
    },
    "insertAfter": {
    "type": "string",
    "description": "The position of the new object. The new object will be added after the specified one. \n\nIf `null`, the new object will be placed in the last position. \n\nIf set to empty string, the new object will be placed in the first position. \n\nOnly applicable for objects based on schemas with ordered objects (schema's **ordered** parameter is set to `true`).",
    "example": "Y2ktaGdyb3VwLTEyMythZjhjOThlOS0wN2I0LTMyMGEtOTQzNi02NTEyMmVlNWY4NGQ="
    },
    "schemaId": {
    "type": "string",
    "description": "The schema on which the object is based.",
    "example": "builtin:anomaly.infrastructure"
    },
    "value": {
    "$ref": "#/components/schemas/SettingsValue"
    },
    "scope": {
    "type": "string",
    "description": "The scope that the object targets.",
    "example": "HOST-D3A3C5A146830A79"
    }
    },
    "description": "Configuration of a new settings object."
    },
    "SettingsObjectUpdate": {
    "required": [
    "value"
    ],
    "type": "object",
    "properties": {
    "schemaVersion": {
    "type": "string",
    "description": "The version of the schema on which the object is based.",
    "example": "1.0.0"
    },
    "updateToken": {
    "type": "string",
    "description": "The update token of the object. You can use it to detect simultaneous modifications by different users. \n\nIt is generated upon retrieval (GET requests). If set on update (PUT request) or deletion, the update/deletion will be allowed only if there wasn't any change between the retrieval and the update. \n\nIf omitted on update/deletion, the operation overrides the current value or deletes it without any checks.",
    "example": "Y2ktaGdyb3VwLTEyMythZjhjOThlOS0wN2I0LTMyMGEtOTQzNi02NTEyMmVlNWY4NGQ="
    },
    "value": {
    "$ref": "#/components/schemas/SettingsValue"
    }
    },
    "description": "An update of a settings object."
    },
    "SchemaList": {
    "type": "object",
    "properties": {
    "items": {
    "type": "array",
    "description": "A list of settings schemas.",
    "items": {
    "$ref": "#/components/schemas/SchemaStub"
    }
    },
    "totalCount": {
    "type": "integer",
    "description": "The number of schemas in the list.",
    "format": "int64",
    "example": 1
    }
    },
    "description": "The list of available settings schemas."
    },
    "SchemaStub": {
    "type": "object",
    "properties": {
    "latestSchemaVersion": {
    "type": "string",
    "description": "The most recent version of the schema.",
    "example": "1.4.2"
    },
    "schemaId": {
    "type": "string",
    "description": "The ID of the schema.",
    "example": "builtin:anomaly.infrastructure"
    },
    "displayName": {
    "type": "string",
    "description": "The name of the schema.",
    "example": "Anomaly Detection for Infrastructure"
    }
    },
    "description": "The short representation of the settings schema."
    },
    "ComplexConstraint": {
    "type": "object",
    "properties": {
    "customMessage": {
    "type": "string",
    "description": "A custom message for invalid values."
    },
    "maximumPropertyCount": {
    "type": "integer",
    "description": "The maximum number of properties that can be set.",
    "format": "int32",
    "example": 2
    },
    "customValidatorId": {
    "type": "string",
    "description": "The ID of a custom validator.",
    "example": "my-min-max"
    },
    "minimumPropertyCount": {
    "type": "integer",
    "description": "The minimum number of properties that must be set.",
    "format": "int32",
    "example": 1
    },
    "properties": {
    "type": "array",
    "description": "A list of properties (defined by IDs) that are used to check the constraint.",
    "items": {
    "type": "string",
    "description": "A list of properties (defined by IDs) that are used to check the constraint."
    }
    },
    "type": {
    "type": "string",
    "description": "The type of the constraint.",
    "enum": [
    "CUSTOM_VALIDATOR_REF",
    "GREATER_THAN",
    "GREATER_THAN_OR_EQUAL",
    "LESS_THAN",
    "LESS_THAN_OR_EQUAL",
    "PROPERTY_COUNT_RANGE",
    "UNKNOWN"
    ]
    }
    },
    "description": "A constraint on the values accepted for a complex settings property."
    },
    "Constraint": {
    "type": "object",
    "properties": {
    "customMessage": {
    "type": "string",
    "description": "A custom message for invalid values.",
    "example": "customConstraintMessage"
    },
    "maxLength": {
    "type": "integer",
    "description": "The maximum allowed length of string values.",
    "format": "int32",
    "example": 20
    },
    "minLength": {
    "type": "integer",
    "description": "The minimum required length of string values.",
    "format": "int32",
    "example": 7
    },
    "uniqueProperties": {
    "type": "array",
    "description": "A list of properties for which the combination of values must be unique.",
    "example": [
    "my-prop-1",
    "my-prop-2"
    ],
    "items": {
    "type": "string",
    "description": "A list of properties for which the combination of values must be unique.",
    "example": "[\"my-prop-1\",\"my-prop-2\"]"
    }
    },
    "customValidatorId": {
    "type": "string",
    "description": "The ID of a custom validator.",
    "example": "my-min-max"
    },
    "maximum": {
    "type": "number",
    "description": "The maximum allowed value.",
    "example": 200
    },
    "minimum": {
    "type": "number",
    "description": "The minimum allowed value.",
    "example": 3
    },
    "type": {
    "type": "string",
    "description": "The type of the constraint.",
    "example": "UNKNOWN",
    "enum": [
    "CUSTOM_VALIDATOR_REF",
    "LENGTH",
    "NOT_BLANK",
    "NOT_EMPTY",
    "NO_WHITESPACE",
    "PATTERN",
    "RANGE",
    "REGEX",
    "TRIMMED",
    "UNIQUE",
    "UNKNOWN"
    ]
    },
    "pattern": {
    "type": "string",
    "description": "The regular expression pattern for valid string values.",
    "example": "^([a-z]|[0-9]|\\-|\\_|\\+|\\.)+\\@([a-z]|[0-9]|-){2,}\\.([a-z]|[0-9]|-){2,}(\\.[a-z]{2,})?$"
    }
    },
    "description": "A constraint on the values accepted for a settings property."
    },
    "DatasourceDefinition": {
    "type": "object",
    "properties": {
    "validate": {
    "type": "boolean",
    "description": "Whether to validate input to only allow values returned by the datasource."
    },
    "filterProperties": {
    "uniqueItems": true,
    "type": "array",
    "description": "The properties to filter the datasource options on.",
    "items": {
    "type": "string",
    "description": "The properties to filter the datasource options on."
    }
    },
    "fullContext": {
    "type": "boolean",
    "description": "Whether this datasource expects full setting payload as the context."
    },
    "useApiSearch": {
    "type": "boolean",
    "description": "If true, the datasource should use the api to filter the results instead of client-side filtering."
    },
    "identifier": {
    "type": "string",
    "description": "The identifier of a custom data source of the property's value."
    }
    },
    "description": "Configuration of a datasource for a property."
    },
    "EnumType": {
    "type": "object",
    "properties": {
    "enumClass": {
    "type": "string",
    "description": "An existing Java enum class that holds the allowed values of the enum.",
    "example": "enumClass"
    },
    "items": {
    "type": "array",
    "description": "A list of allowed values of the enum.",
    "items": {
    "$ref": "#/components/schemas/EnumValue"
    }
    },
    "type": {
    "type": "string",
    "description": "The type of the property.",
    "example": "enum",
    "enum": [
    "enum"
    ]
    },
    "documentation": {
    "type": "string",
    "description": "An extended description and/or links to documentation.",
    "example": "typeDocumentation"
    },
    "displayName": {
    "type": "string",
    "description": "The display name of the property.",
    "example": "typeDisplayName"
    },
    "description": {
    "type": "string",
    "description": "A short description of the property.",
    "example": "typeDescription"
    }
    },
    "description": "Definition of an enum property."
    },
    "EnumValue": {
    "type": "object",
    "properties": {
    "enumInstance": {
    "type": "string",
    "description": "The name of the value in an existing Java enum class.",
    "example": "exampleJavaEnumValue"
    },
    "icon": {
    "type": "string",
    "description": "The icon of the value.",
    "example": "checkmark"
    },
    "value": {
    "type": "object",
    "description": "The allowed value of the enum.",
    "example": "exampleValue"
    },
    "displayName": {
    "type": "string",
    "description": "The display name of the value.",
    "example": "exampleDisplayName"
    },
    "description": {
    "type": "string",
    "description": "A short description of the value.",
    "example": "exampleDescription"
    }
    },
    "description": "An allowed value for an enum property."
    },
    "Item": {
    "type": "object",
    "properties": {
    "referencedType": {
    "type": "string",
    "description": "The type referenced by the item's value.",
    "example": "itemReferencedType"
    },
    "documentation": {
    "type": "string",
    "description": "An extended description and/or links to documentation.",
    "example": "propertyDocumentation"
    },
    "datasource": {
    "$ref": "#/components/schemas/DatasourceDefinition"
    },
    "constraints": {
    "type": "array",
    "description": "A list of constraints limiting the values to be accepted.",
    "items": {
    "$ref": "#/components/schemas/Constraint"
    }
    },
    "type": {
    "type": "object",
    "description": "The type of the item's value."
    },
    "displayName": {
    "type": "string",
    "description": "The display name of the item.",
    "example": "itemDisplayName"
    },
    "description": {
    "type": "string",
    "description": "A short description of the item.",
    "example": "itemDescription"
    },
    "subType": {
    "type": "string",
    "description": "The subtype of the item's value.",
    "example": "itemSubType"
    }
    },
    "description": "An item of a collection property."
    },
    "Precondition": {
    "type": "object",
    "properties": {
    "expectedValues": {
    "type": "array",
    "description": "A list of valid values of the property. \n\nOnly applicable to properties of the `IN` type.",
    "example": "expectedValues",
    "items": {
    "type": "object"
    }
    },
    "preconditions": {
    "type": "array",
    "description": "A list of child preconditions to be evaluated. \n\nOnly applicable to properties of the `AND` and `OR` types.",
    "items": {
    "$ref": "#/components/schemas/Precondition"
    }
    },
    "expectedValue": {
    "type": "object",
    "description": "The expected value of the property. \n\nOnly applicable to properties of the `EQUALS` type.",
    "example": "expectedValue"
    },
    "precondition": {
    "$ref": "#/components/schemas/Precondition"
    },
    "property": {
    "type": "string",
    "description": "The property to be evaluated.",
    "example": "propertyToEvaluate"
    },
    "type": {
    "type": "string",
    "description": "The type of the precondition.",
    "example": "NULL",
    "enum": [
    "AND",
    "EQUALS",
    "IN",
    "NOT",
    "NULL",
    "OR"
    ]
    }
    },
    "description": "A precondition for visibility of a property."
    },
    "PropertyDefinition": {
    "type": "object",
    "properties": {
    "referencedType": {
    "type": "string",
    "description": "The type referenced by the property value",
    "example": "propertyReferencedType"
    },
    "items": {
    "$ref": "#/components/schemas/Item"
    },
    "documentation": {
    "type": "string",
    "description": "An extended description and/or links to documentation.",
    "example": "propertyDocumentation"
    },
    "maxObjects": {
    "type": "integer",
    "description": "The maximum number of **objects** in a collection property. \n\n Has the value of `1` for singletons.",
    "format": "int32"
    },
    "precondition": {
    "$ref": "#/components/schemas/Precondition"
    },
    "minObjects": {
    "type": "integer",
    "description": "The minimum number of **objects** in a collection property.",
    "format": "int32",
    "example": 1
    },
    "datasource": {
    "$ref": "#/components/schemas/DatasourceDefinition"
    },
    "constraints": {
    "type": "array",
    "description": "A list of constraints limiting the values to be accepted.",
    "items": {
    "$ref": "#/components/schemas/Constraint"
    }
    },
    "default": {
    "type": "object",
    "description": "The default value to be used when no value is provided. \n\nIf a non-singleton has the value of `null`, it means an empty collection.",
    "example": "propertyDefaultValue"
    },
    "type": {
    "type": "object",
    "description": "The type of the property's value."
    },
    "displayName": {
    "type": "string",
    "description": "The display name of the property.",
    "example": "propertyDisplayName"
    },
    "description": {
    "type": "string",
    "description": "A short description of the property.",
    "example": "propertyDescription"
    },
    "metadata": {
    "type": "object",
    "additionalProperties": {
    "type": "string",
    "description": "Metadata of the property."
    },
    "description": "Metadata of the property."
    },
    "subType": {
    "type": "string",
    "description": "The subtype of the property's value.",
    "example": "propertySubType"
    },
    "nullable": {
    "type": "boolean",
    "description": "The value can (`true`) or can't (`false`) be `null`.",
    "example": true
    }
    },
    "description": "Configuration of a property in a settings schema."
    },
    "SchemaDefinitionRestDto": {
    "type": "object",
    "properties": {
    "dynatrace": {
    "type": "string",
    "description": "The version of the data format.",
    "example": "1"
    },
    "schemaId": {
    "type": "string",
    "description": "The ID of the schema.",
    "example": "builtin:anomaly.infrastructure"
    },
    "displayName": {
    "type": "string",
    "description": "The display name of the schema.",
    "example": "Anomaly detection for infrastructure"
    },
    "description": {
    "type": "string",
    "description": "A short description of the schema.",
    "example": "Dynatrace automatically detects infrastructure-related performance anomalies such as high CPU saturation, memory outages, and low disk-space conditions"
    },
    "documentation": {
    "type": "string",
    "description": "An extended description of the schema and/or links to documentation."
    },
    "schemaGroups": {
    "uniqueItems": true,
    "type": "array",
    "description": "Names of the groups, which the schema belongs to.",
    "example": [
    "group:some.1",
    "group:some.2"
    ],
    "items": {
    "type": "string"
    }
    },
    "version": {
    "type": "string",
    "description": "The version of the schema.",
    "example": "1.4.2"
    },
    "multiObject": {
    "type": "boolean",
    "description": "Multiple (`true`) objects per scope are permitted or a single (`false`) object per scope is permitted."
    },
    "ordered": {
    "type": "boolean",
    "description": "If `true` the order of objects has semantic significance. \n\nOnly applicable when **multiObject** is set to `true`."
    },
    "maxObjects": {
    "type": "integer",
    "description": "The maximum amount of objects per scope. \n\nOnly applicable when **multiObject** is set to `true`.",
    "format": "int32",
    "example": 10
    },
    "allowedScopes": {
    "type": "array",
    "description": "A list of scopes where the schema can be used.",
    "example": [
    "host",
    "application"
    ],
    "items": {
    "type": "string"
    }
    },
    "enums": {
    "type": "object",
    "additionalProperties": {
    "$ref": "#/components/schemas/EnumType"
    },
    "description": "A list of definitions of enum properties."
    },
    "types": {
    "type": "object",
    "additionalProperties": {
    "$ref": "#/components/schemas/SchemaType"
    },
    "description": "A list of definitions of types. \n\n A type is a complex property that contains its own set of subproperties."
    },
    "properties": {
    "type": "object",
    "additionalProperties": {
    "$ref": "#/components/schemas/PropertyDefinition"
    },
    "description": "A list of schema's properties."
    },
    "constraints": {
    "type": "array",
    "description": "A list of constrains limiting the values to be accepted by the schema.",
    "items": {
    "$ref": "#/components/schemas/ComplexConstraint"
    }
    },
    "metadata": {
    "type": "object",
    "additionalProperties": {
    "type": "string",
    "description": "Metadata of the setting."
    },
    "description": "Metadata of the setting."
    }
    }
    },
    "SchemaType": {
    "type": "object",
    "properties": {
    "summaryPattern": {
    "type": "string",
    "description": "The pattern for the summary (for example, \"Alert after *X* minutes.\") of the configuration in the UI.",
    "example": "summaryPatternOfType"
    },
    "constraints": {
    "type": "array",
    "description": "A list of constraints limiting the values to be accepted.",
    "items": {
    "$ref": "#/components/schemas/ComplexConstraint"
    }
    },
    "version": {
    "type": "string",
    "description": "The version of the type.",
    "example": "0"
    },
    "versionInfo": {
    "type": "string",
    "description": "A short description of the version.",
    "example": "Added new property"
    },
    "properties": {
    "type": "object",
    "additionalProperties": {
    "$ref": "#/components/schemas/PropertyDefinition"
    },
    "description": "Definition of properties that can be persisted."
    },
    "documentation": {
    "type": "string",
    "description": "An extended description and/or links to documentation.",
    "example": "typeDocumentation"
    },
    "displayName": {
    "type": "string",
    "description": "The display name of the property.",
    "example": "typeDisplayName"
    },
    "description": {
    "type": "string",
    "description": "A short description of the property.",
    "example": "typeDescription"
    }
    },
    "description": "A list of definitions of types. \n\n A type is a complex property that contains its own set of subproperties."
    },
    "SyntheticLocationIdsDto": {
    "required": [
    "entityId",
    "geoLocationId"
    ],
    "type": "object",
    "properties": {
    "entityId": {
    "type": "string",
    "description": "Entity ID to be transferred"
    },
    "geoLocationId": {
    "type": "string",
    "description": "GeoLocation ID to be transferred"
    }
    },
    "description": "A DTO for synthetic Location IDs."
    },
    "PrivateSyntheticLocation": {
    "required": [
    "entityId",
    "latitude",
    "longitude",
    "name",
    "nodes",
    "type"
    ],
    "type": "object",
    "description": "Configuration of a private synthetic location.\n\n **countryCode**, **regionCode**, **city** parameters are optional as they can be retrieved based on **latitude** and **longitude** of location.",
    "example": {
    "type": "PRIVATE",
    "name": "Linz Location",
    "latitude": 48.306351,
    "longitude": 14.287399,
    "nodes": [
    "93302281"
    ],
    "status": "ENABLED",
    "availabilityLocationOutage": false,
    "availabilityNodeOutage": false,
    "availabilityLocationNodeOutageDelayInMinutes": 5,
    "availabilityNotificationsEnabled": true,
    "autoUpdateChromium": true
    },
    "allOf": [
    {
    "$ref": "#/components/schemas/SyntheticLocation"
    },
    {
    "type": "object",
    "properties": {
    "nodes": {
    "type": "array",
    "description": "A list of synthetic nodes belonging to the location. \n\n You can retrieve the list of available nodes with the [GET all nodes](https://dt-url.net/miy3rpl) call.",
    "items": {
    "type": "string"
    }
    },
    "availabilityLocationOutage": {
    "type": "boolean",
    "description": "The alerting of location outage is enabled (`true`) or disabled (`false`)."
    },
    "availabilityNodeOutage": {
    "type": "boolean",
    "description": "The alerting of node outage is enabled (`true`) or disabled (`false`). \n\n If enabled, the outage of *any* node in the location triggers an alert."
    },
    "locationNodeOutageDelayInMinutes": {
    "maximum": 5,
    "minimum": 1,
    "type": "integer",
    "description": "Alert if the location or node outage lasts longer than *X* minutes. \n\n Only applicable when **availabilityLocationOutage** or **availabilityNodeOutage** is set to `true`.",
    "format": "int32"
    },
    "availabilityNotificationsEnabled": {
    "type": "boolean",
    "description": "The notifications of location and node outage is enabled (`true`) or disabled (`false`)."
    },
    "autoUpdateChromium": {
    "type": "boolean",
    "description": "Auto upgrade of Chromium is enabled (`true`) or disabled (`false`)."
    }
    }
    }
    ]
    },
    "LocationCollectionElement": {
    "required": [
    "entityId",
    "geoLocationId",
    "name",
    "type"
    ],
    "type": "object",
    "properties": {
    "name": {
    "type": "string",
    "description": "The name of the location."
    },
    "entityId": {
    "type": "string",
    "description": "The Dynatrace entity ID of the location."
    },
    "type": {
    "type": "string",
    "description": "The type of the location.",
    "enum": [
    "CLUSTER",
    "PRIVATE",
    "PUBLIC"
    ]
    },
    "cloudPlatform": {
    "type": "string",
    "description": "The cloud provider where the location is hosted. \n\n Only applicable to `PUBLIC` locations.",
    "enum": [
    "ALIBABA",
    "AMAZON_EC2",
    "AZURE",
    "DYNATRACE_CLOUD",
    "GOOGLE_CLOUD",
    "INTEROUTE",
    "OTHER",
    "UNDEFINED"
    ]
    },
    "ips": {
    "type": "array",
    "description": "The list of IP addresses assigned to the location. \n\n Only applicable to `PUBLIC` locations.",
    "items": {
    "type": "string"
    }
    },
    "stage": {
    "type": "string",
    "description": "The release stage of the location.",
    "enum": [
    "BETA",
    "COMING_SOON",
    "GA"
    ]
    },
    "status": {
    "type": "string",
    "description": "The status of the location.",
    "enum": [
    "DISABLED",
    "ENABLED",
    "HIDDEN"
    ]
    },
    "geoLocationId": {
    "type": "string",
    "description": "The Dynatrace GeoLocation ID of the location."
    }
    },
    "description": "A synthetic location."
    },
    "SyntheticLocations": {
    "required": [
    "locations"
    ],
    "type": "object",
    "properties": {
    "locations": {
    "type": "array",
    "description": "A list of synthetic locations.",
    "items": {
    "$ref": "#/components/schemas/LocationCollectionElement"
    }
    }
    },
    "description": "A list of synthetic locations.",
    "example": {
    "locations": [
    {
    "name": "Gdansk",
    "entityId": "SYNTHETIC_LOCATION-53F47ECB33907667",
    "geoLocationId": "GEOLOCATION-95196F3C9A4F4215",
    "type": "PUBLIC",
    "cloudPlatform": "AMAZON_EC2",
    "ips": [
    "134.189.153.97",
    "134.189.153.98"
    ],
    "stage": "GA",
    "status": "ENABLED",
    "capabilities": [
    "BROWSER",
    "HTTP"
    ]
    },
    {
    "name": "My private location",
    "entityId": "SYNTHETIC_LOCATION-53F47ECB33907667",
    "geoLocationId": "GEOLOCATION-95196F3C9A4F4215",
    "type": "PRIVATE",
    "status": "ENABLED"
    }
    ]
    }
    },
    "PublicSyntheticLocation": {
    "required": [
    "browserType",
    "browserVersion",
    "cloudPlatform",
    "entityId",
    "ips",
    "latitude",
    "longitude",
    "name",
    "stage",
    "type"
    ],
    "type": "object",
    "description": "Configuration of a public synthetic location.",
    "example": {
    "entityId": "GEOLOCATION-95196F3C9A4F4215",
    "type": "PUBLIC",
    "name": "Amazon US East",
    "countryCode": "US",
    "regionCode": "VA",
    "city": "Amazon US East (N. Virginia)",
    "latitude": 39.0436,
    "longitude": -77.4875,
    "cloudPlatform": "AMAZON_EC2",
    "ips": [
    "134.189.153.97",
    "134.189.153.98"
    ],
    "stage": "GA",
    "browserType": "Chrome",
    "browserVersion": "69.0.3497.81",
    "status": "ENABLED",
    "capabilities": [
    "BROWSER",
    "HTTP"
    ]
    },
    "allOf": [
    {
    "$ref": "#/components/schemas/SyntheticLocation"
    },
    {
    "type": "object",
    "properties": {
    "cloudPlatform": {
    "type": "string",
    "description": "The cloud provider where the location is hosted.",
    "enum": [
    "ALIBABA",
    "AMAZON_EC2",
    "AZURE",
    "DYNATRACE_CLOUD",
    "GOOGLE_CLOUD",
    "INTEROUTE",
    "OTHER",
    "UNDEFINED"
    ]
    },
    "ips": {
    "uniqueItems": true,
    "type": "array",
    "description": "The list of IP addresses assigned to the location.",
    "items": {
    "type": "string"
    }
    },
    "stage": {
    "type": "string",
    "description": "The stage of the location.",
    "enum": [
    "BETA",
    "COMING_SOON",
    "GA"
    ]
    },
    "browserType": {
    "type": "string",
    "description": "The type of the browser the location is using to execute browser monitors."
    },
    "browserVersion": {
    "type": "string",
    "description": "The version of the browser the location is using to execute browser monitors."
    },
    "capabilities": {
    "type": "array",
    "description": "A list of location capabilities.",
    "items": {
    "type": "string"
    }
    }
    }
    }
    ]
    },
    "SyntheticLocation": {
    "required": [
    "entityId",
    "latitude",
    "longitude",
    "name",
    "type"
    ],
    "type": "object",
    "properties": {
    "entityId": {
    "type": "string",
    "description": "The Dynatrace entity ID of the location."
    },
    "type": {
    "type": "string",
    "description": "Defines the actual set of fields depending on the value. See one of the following objects: \n\n* `PUBLIC` -> PublicSyntheticLocation \n* `PRIVATE` -> PrivateSyntheticLocation \n* `CLUSTER` -> PrivateSyntheticLocation \n",
    "enum": [
    "CLUSTER",
    "PRIVATE",
    "PUBLIC"
    ]
    },
    "name": {
    "type": "string",
    "description": "The name of the location."
    },
    "countryCode": {
    "type": "string",
    "description": "The country code of the location. \n\n Use the alpha-2 code of the [ISO 3166-2 standard](https://dt-url.net/iso3166-2), (for example, `AT` for Austria or `PL` for Poland)."
    },
    "regionCode": {
    "type": "string",
    "description": "The region code of the location. \n\n For the [USA](https://dt-url.net/iso3166us) or [Canada](https://dt-url.net/iso3166ca) use ISO 3166-2 state codes (without `US-` or `CA-` prefix), for example, `VA` for Virginia or `OR` for Oregon. \n\n For the rest of the world use [FIPS 10-4 codes](https://dt-url.net/fipscodes)."
    },
    "city": {
    "type": "string",
    "description": "The city of the location."
    },
    "latitude": {
    "type": "number",
    "description": "The latitude of the location in `DDD.dddd` format.",
    "format": "double"
    },
    "longitude": {
    "type": "number",
    "description": "The longitude of the location in `DDD.dddd` format.",
    "format": "double"
    },
    "status": {
    "type": "string",
    "description": "The status of the location: \n\n* `ENABLED`: The location is displayed as active in the UI. You can assign monitors to the location. \n* `DISABLED`: The location is displayed as inactive in the UI. You can't assign monitors to the location. Monitors already assigned to the location will stay there and will be executed from the location. \n* `HIDDEN`: The location is not displayed in the UI. You can't assign monitors to the location. You can only set location as `HIDDEN` when no monitor is assigned to it.",
    "enum": [
    "DISABLED",
    "ENABLED",
    "HIDDEN"
    ]
    }
    },
    "description": "Configuration of a synthetic location. \n\n **countryCode**, **regionCode**, **city** parameters are optional as they can be retrieved based on **latitude** and **longitude** of location.\n\n The actual set of fields depends on the **type** of the location.",
    "discriminator": {
    "propertyName": "type"
    }
    },
    "Node": {
    "required": [
    "activeGateVersion",
    "autoUpdateEnabled",
    "browserMonitorsEnabled",
    "browserType",
    "browserVersion",
    "entityId",
    "healthCheckStatus",
    "hostname",
    "ips",
    "oneAgentRoutingEnabled ",
    "operatingSystem",
    "playerVersion",
    "status",
    "version"
    ],
    "type": "object",
    "properties": {
    "entityId": {
    "type": "string",
    "description": "The ID of the synthetic node."
    },
    "hostname": {
    "type": "string",
    "description": "The hostname of the synthetic node."
    },
    "ips": {
    "type": "array",
    "description": "The IP of the synthetic node.",
    "items": {
    "type": "string"
    }
    },
    "version": {
    "type": "string",
    "description": "The version of the synthetic node."
    },
    "browserMonitorsEnabled": {
    "type": "boolean",
    "description": "The synthetic node is able to execute browser monitors (`true`) or not (`false`)."
    },
    "activeGateVersion": {
    "type": "string",
    "description": "The version of the Active Gate."
    },
    "oneAgentRoutingEnabled ": {
    "type": "boolean",
    "description": "The Active Gate has the One Agent routing enabled ('true') or not ('false')."
    },
    "operatingSystem": {
    "type": "string",
    "description": "The Active Gate's host operating system."
    },
    "autoUpdateEnabled": {
    "type": "boolean",
    "description": "The Active Gate has the Auto update option enabled ('true') or not ('false')"
    },
    "status": {
    "type": "string",
    "description": "The status of the synthetic node."
    },
    "playerVersion": {
    "type": "string",
    "description": "The version of the synthetic player."
    },
    "healthCheckStatus": {
    "type": "string",
    "description": "The health check status of the synthetic node."
    },
    "browserType": {
    "type": "string",
    "description": "The browser type."
    },
    "browserVersion": {
    "type": "string",
    "description": "The browser version."
    }
    },
    "description": "Configuration of a synthetic node. \n\n A *synthetic node* is an ActiveGate that is able to execute synthetic monitors.",
    "example": {
    "entityId": "3086117876",
    "hostname": "gdn.dyna.trace",
    "ips": [
    "238.245.160.14"
    ],
    "version": "1.161.0.20181210-173639",
    "browserMonitorsEnabled": true,
    "activeGateVersion": "1.172.2.20190607-040913",
    "oneAgentRoutingEnabled": true,
    "operatingSystem": "Linux",
    "autoUpdateEnabled": true,
    "status": "Running",
    "playerVersion": "1.179.0.20190920-145430",
    "healthCheckStatus": "Ok",
    "browserType": "Chrome",
    "browserVersion": "69.0.3497.81"
    }
    },
    "NodeCollectionElement": {
    "required": [
    "activeGateVersion",
    "autoUpdateEnabled",
    "browserMonitorsEnabled",
    "entityId",
    "healthCheckStatus",
    "hostname",
    "ips",
    "oneAgentRoutingEnabled ",
    "operatingSystem",
    "playerVersion",
    "status",
    "version"
    ],
    "type": "object",
    "properties": {
    "entityId": {
    "type": "string",
    "description": "The ID of a node."
    },
    "hostname": {
    "type": "string",
    "description": "The hostname of a node."
    },
    "ips": {
    "type": "array",
    "description": "The IP of a node.",
    "items": {
    "type": "string"
    }
    },
    "version": {
    "type": "string",
    "description": "The version of a node"
    },
    "browserMonitorsEnabled": {
    "type": "boolean",
    "description": "Browser check capabilities enabled flag."
    },
    "activeGateVersion": {
    "type": "string",
    "description": "The version of the Active Gate."
    },
    "oneAgentRoutingEnabled ": {
    "type": "boolean",
    "description": "The Active Gate has the One Agent routing enabled ('true') or not ('false')."
    },
    "operatingSystem": {
    "type": "string",
    "description": "The Active Gate's host operating system."
    },
    "autoUpdateEnabled": {
    "type": "boolean",
    "description": "The Active Gate has the Auto update option enabled ('true') or not ('false')"
    },
    "status": {
    "type": "string",
    "description": "The status of the synthetic node."
    },
    "playerVersion": {
    "type": "string",
    "description": "The version of the synthetic player."
    },
    "healthCheckStatus": {
    "type": "string",
    "description": "The health check status of the synthetic node."
    }
    },
    "description": "The short representation of a synthetic object. Only contains the ID and the display name."
    },
    "Nodes": {
    "required": [
    "nodes"
    ],
    "type": "object",
    "properties": {
    "nodes": {
    "type": "array",
    "description": "A list of synthetic nodes",
    "items": {
    "$ref": "#/components/schemas/NodeCollectionElement"
    }
    }
    },
    "description": "A list of synthetic nodes",
    "example": {
    "nodes": [
    {
    "entityId": "3086117876",
    "hostname": "gdn.dyna.trace",
    "ips": [
    "238.245.160.14"
    ],
    "version": "1.161.0.20181210-173639",
    "browserMonitorsEnabled": true,
    "activeGateVersion": "1.172.2.20190607-040913",
    "oneAgentRoutingEnabled": true,
    "operatingSystem": "Linux",
    "autoUpdateEnabled": true,
    "status": "Running",
    "playerVersion": "1.179.0.20190920-145430",
    "healthCheckStatus": "Ok"
    }
    ]
    }
    }
    },
    "securitySchemes": {
    "Api-Token": {
    "type": "apiKey",
    "description": "Dynatrace API Token\n\n The token is passed in the **Authorization** header in the following format: `Authorization: Api-Token abcdefjhij1234567890`.",
    "name": "Authorization",
    "in": "header"
    }
    }
    }
    }